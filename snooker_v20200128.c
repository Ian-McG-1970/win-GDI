#define WIN32_LEAN_AND_MEAN
#include <windows.h>   	// required for all Windows applications
#include <stdlib.h>
#include <stdio.h>
#include <math.h>


/*
3560mm x 1780mm
86mm
52mm
35.6/2=17.8
17.8/2=8.9
0.60
0.86
0.52
17.8-0.6
0.43
draw floor
draw lines
draw unobscuring faces
sort obscuring faces
draw obscuring faces
*/

#define IDM_EXIT           106

#define INITIAL_DIB_WIDTH  	128		// initial dimensions of DIB
#define INITIAL_DIB_HEIGHT	96		//  into which we'll draw
#define MAX_POLY_VERTS      256
#define MAX_OBJECTS 				64
#define MAX_OBJECT_POINTS   65535
#define MAX_SCREEN_HEIGHT   INITIAL_DIB_HEIGHT*2
#define PI                  3.141592f
#define NUM_FRUSTUM_PLANES  4
#define EPSILON  0.0001f
#define FIELD_OF_VIEW 2.0f //3.0 //4.0 //2.0

#define LEFT 0
#define RIGHT 1

#define ALL_ON 0
#define ALL_OFF 1
#define INTERSECTING 2

#define CLIP_LEFT 1
#define CLIP_RIGHT 2
#define CLIP_BOTTOM 4
#define CLIP_TOP 8

#define SPEED PI / 16383.0f //1024.0f //4096 //512.0 //2048.0 //1024.0
#define ACCEL 0.05f
#define FRICTION 0.97f //0.95f

#define CT 2 // colour table
#define CS 3 // colour shdaow
#define CWT 4 // white
#define CWB 5
#define CRT 6 // red
#define CRB 7
#define CYT 8 // yellow
#define CYB 9
#define CGT 10 // green
#define CGB 11
#define CBRT 12 // brown
#define CBRB 13
#define CBLT 14 // blue 
#define CBLB 15
#define CPT 16 // pink
#define CPB 17
#define CBKT 18 // black
#define CBKB 19

#define TABLE 0
#define SHADOW 2
#define WHITE 3
#define RED 4
#define YELLOW 5
#define GREEN 6
#define BROWN 7
#define BLUE 8
#define PINK 9
#define BLACK 10

#define CUSHION_T 11
#define CUSHION_B 12
#define CUSHION_TR 13
#define CUSHION_BR 14
#define CUSHION_TL 15
#define CUSHION_BL 16

typedef struct 
{
	float x;
  float y;
  float z;
} point_t;

typedef struct 
{
  signed short int x, y;
} point2D_t;

typedef struct  
{
  point_t center;
  float boundingsphere;
  float vdist;
  BYTE type;
} visibleobject;

typedef struct 
{
	float distance;
	point_t normal;
} plane_t;

typedef struct 
{
  BYTE ClipCode;
  point_t Point;
} Point3D;

typedef struct 
{
  BYTE Points; 		// number of points
  point_t *Point; // pointer to list of points
  BYTE Faces; 		// number of faces
  BYTE *Face; 		// pointer to list of faces (face point count, face colour, face point index, face point count, face colour, face point index, etc)
  float BoundingSphere; // object bounding sphere
} OBJECT;

typedef struct 
{
  point_t Location;
  BYTE Type;    // object type
} OBJECTS;

struct pBITMAPINFO
{
  BITMAPINFOHEADER bmiHeader;
  RGBQUAD bmiColors[256];
} BMInfo;

struct pLOGPALETTE
{
  WORD palVersion;
  WORD palNumEntries;
  PALETTEENTRY palPalEntry[256];
} PalInfo;

char *pDIB, *pDIBBase;		// pointers to DIB section we'll draw into
HBITMAP hDIBSection;        // handle of DIB section
HWND hwndOutput;
int DIBWidth=INITIAL_DIB_WIDTH, DIBHeight=INITIAL_DIB_HEIGHT, DIBPitch;

float currentspeed=0;
point_t currentpos={0,0,0};
point_t currentdir={0,0,0};
point_t currentturnspeed={0,0,0};

signed short int xcenter, ycenter; 
float xscreenscale, yscreenscale, maxscale;

plane_t frustumplanes[NUM_FRUSTUM_PLANES];
point_t vpn, vright, vup;
Point3D Vertex[MAX_POLY_VERTS];

OBJECTS groundobjects[] = { 
{ {0,0,0},  0}, // table

{ {-800,0,-1700},  SHADOW}, // shadows
{ {-800,0,-100},  SHADOW},
{ {0,0,-200},  SHADOW},
{ {+100,0,-200},  SHADOW},
{ {+200,0,-200},  SHADOW},

{ {-200,0,-100},  SHADOW},
{ {-100,0,-100},  SHADOW},
{ {0,0,-100},  SHADOW},
{ {+100,0,-100},  SHADOW},
{ {+200,0,-100},  SHADOW},

{ {-200,0,0},  SHADOW},
{ {-100,0,0},  SHADOW},
{ {0,0,0},  SHADOW},
{ {+100,0,0},  SHADOW},
{ {+200,0,0},  SHADOW},

{ {-200,0,+100},  SHADOW},
{ {-100,0,+100},  SHADOW},
{ {0,0,+100},  SHADOW},
{ {+100,0,+100},  SHADOW},
{ {+200,0,+100},  SHADOW},

{ {-200,0,+200},  SHADOW},
{ {-100,0,+200},  SHADOW},
{ {0,0,+200},  SHADOW},
{ {+100,0,+200},  SHADOW},
{ {+200,0,+200},  SHADOW},
};

OBJECTS landobjects[] = { 
{ {-800,26,-1700},  WHITE}, // balls
{ {-800,26,-100},  RED},
{ {0,26,-200},  YELLOW},
{ {+100,26,-200},  RED},
{ {+200,26,-200},  GREEN},

{ {-200,26,-100},  RED},
{ {-100,26,-100},  BROWN},
{ {0,26,-100},  RED},
{ {+100,26,-100},  BLUE},
{ {+200,26,-100},  RED},

{ {-200,26,0},  PINK},
{ {-100,26,0},  RED},
{ {0,26,0},  BLACK},
{ {+100,26,0},  RED},
{ {+200,26,0},  WHITE},

{ {-200,26,+100},  RED},
{ {-100,26,+100},  YELLOW},
{ {0,26,+100},  RED},
{ {+100,26,+100},  GREEN},
{ {+200,26,+100},  RED},

{ {-200,26,+200},  BROWN},
{ {-100,26,+200},  BROWN},
{ {0,26,+200},  BROWN},
{ {+100,26,+200},  BROWN},
{ {+200,26,+200},  BROWN},
};

// table = 1820mm*910mm
// ball = 26mm radius

// cushion = 22.0f to 1820.0f-30.0f 
// cushion = -22.0f to -1820.0f+30.0f 

#define VTS 1820.0f // vertical table size
#define HTS VTS/2.0f // horizontal table size
#define PS 80.0f // pocket size

point_t STBPnt[]={
  { -HTS,    0.0f, -VTS+PS },
  { -HTS+PS, 0.0f, -VTS },
  { +HTS-PS, 0.0f, -VTS },
  { +HTS,    0.0f, -VTS+PS },
  { -HTS,    0.0f, +VTS-PS },
  { -HTS+PS, 0.0f, +VTS },
  { +HTS-PS, 0.0f, +VTS },
  { +HTS,    0.0f, +VTS-PS } };
BYTE STBFace[] = {  8, CT, 4,5,6,7,3,2,1,0 };
BYTE STBLine[] = {  0,1, 1,2, 2,3, 3,7, 7,6, 6,5, 5,4, 4,0 };

point_t BallPnt[]={
{ 26.0000, 0.0000, 0.0000 },
{ -26.0000, 0.0000, 0.0000 },
{ 0.0000, 26.0000, 0.0000 },
{ 0.0000, -26.0000, 0.0000 },
{ 0.0000, 0.0000, 26.0000 },
{ 0.0000, 0.0000, -26.0000 },
{ 18.3848, 18.3848, 0.0000 },
{ 18.3848, 0.0000, 18.3848 },
{ 0.0000, 18.3848, 18.3848 },
{ 0.0000, -18.3848, 18.3848 },
{ 18.3848, -18.3848, 0.0000 },
{ -18.3848, 0.0000, 18.3848 },
{ -18.3848, 18.3848, 0.0000 },
{ -18.3848, -18.3848, 0.0000 },
{ 18.3848, 0.0000, -18.3848 },
{ 0.0000, -18.3848, -18.3848 },
{ 0.0000, 18.3848, -18.3848 },
{ -18.3848, 0.0000, -18.3848 },
{ 10.6145, 21.2289, 10.6145 },
{ 10.6145, 10.6145, 21.2289 },
{ 21.2289, 10.6145, 10.6145 },
{ 10.6145, -21.2289, 10.6145 },
{ 21.2289, -10.6145, 10.6145 },
{ 10.6145, -10.6145, 21.2289 },
{ -10.6145, 21.2289, 10.6145 },
{ -21.2289, 10.6145, 10.6145 },
{ -10.6145, 10.6145, 21.2289 },
{ -10.6145, -21.2289, 10.6145 },
{ -10.6145, -10.6145, 21.2289 },
{ -21.2289, -10.6145, 10.6145 },
{ 10.6145, -21.2289, -10.6145 },
{ 10.6145, -10.6145, -21.2289 },
{ 21.2289, -10.6145, -10.6145 },
{ 10.6145, 21.2289, -10.6145 },
{ 21.2289, 10.6145, -10.6145 },
{ 10.6145, 10.6145, -21.2289 },
{ -10.6145, -21.2289, -10.6145 },
{ -21.2289, -10.6145, -10.6145 },
{ -10.6145, -10.6145, -21.2289 },
{ -10.6145, 21.2289, -10.6145 },
{ -10.6145, 10.6145, -21.2289 },
{ -21.2289, 10.6145, -10.6145 },
{ 0.0000, 24.0209, 9.9498 },
{ 9.9498, 24.0209, 0.0000 },
{ 24.0209, 0.0000, 9.9498 },
{ 24.0209, 9.9498, 0.0000 },
{ 0.0000, 9.9498, 24.0209 },
{ 9.9498, 0.0000, 24.0209 },
{ 9.9498, -24.0209, 0.0000 },
{ 0.0000, -24.0209, 9.9498 },
{ 0.0000, -9.9498, 24.0209 },
{ 24.0209, -9.9498, 0.0000 },
{ -9.9498, 24.0209, 0.0000 },
{ -9.9498, 0.0000, 24.0209 },
{ -24.0209, 9.9498, 0.0000 },
{ -24.0209, 0.0000, 9.9498 },
{ -9.9498, -24.0209, 0.0000 },
{ -24.0209, -9.9498, 0.0000 },
{ 0.0000, -24.0209, -9.9498 },
{ 24.0209, 0.0000, -9.9498 },
{ 0.0000, -9.9498, -24.0209 },
{ 9.9498, 0.0000, -24.0209 },
{ 0.0000, 24.0209, -9.9498 },
{ 0.0000, 9.9498, -24.0209 },
{ -9.9498, 0.0000, -24.0209 },
{ -24.0209, 0.0000, -9.9498 }, };

BYTE BallFaceWhite[] = { 
3,   CWT,    18,    19,    20,
3,   CWB,    21,    22,    23,
3,   CWT,    24,    25,    26,
3,    CWB,    27,    28,    29,
3,    CWB,    30,    31,    32,
3,   CWT,    33,    34,    35,
3,    CWB,    36,    37,    38,
3,   CWT,    39,    40,    41,
3,   CWT,    42,    18,    43,
3,   CWT,    20,    44,    45,
3,   CWT,    46,    47,    19,
3,    CWB,    48,    21,    49,
3,    CWB,    23,    47,    50,
3,    CWB,    51,    44,    22,
3,   CWT,    52,    24,    42,
3,   CWT,    26,    53,    46,
3,   CWT,    54,    55,    25,
3,    CWB,    49,    27,    56,
3,    CWB,    29,    55,    57,
3,    CWB,    50,    53,    28,
3,    CWB,    58,    30,    48,
3,    CWB,    32,    59,    51,
3,    CWB,    60,    61,    31,
3,   CWT,    43,    33,    62,
3,   CWT,    35,    61,    63,
3,   CWT,    45,    59,    34,
3,    CWB,    56,    36,    58,
3,    CWB,    38,    64,    60,
3,    CWB,    57,    65,    37,
3,   CWT,    62,    39,    52,
3,   CWT,    41,    65,    54,
3,   CWT,    63,    64,    40,
3,   CWT,     6,    18,    20,
3,   CWT,    18,     8,    19,
3,   CWT,    20,    19,     7,
3,    CWB,     9,    21,    23,
3,    CWB,    21,    10,    22,
3,    CWB,    23,    22,     7,
3,   CWT,     8,    24,    26,
3,   CWT,    24,    12,    25,
3,   CWT,    26,    25,    11,
3,    CWB,    13,    27,    29,
3,    CWB,    27,     9,    28,
3,    CWB,    29,    28,    11,
3,    CWB,    10,    30,    32,
3,    CWB,    30,    15,    31,
3,    CWB,    32,    31,    14,
3,   CWT,    16,    33,    35,
3,   CWT,    33,     6,    34,
3,   CWT,    35,    34,    14,
3,    CWB,    15,    36,    38,
3,    CWB,    36,    13,    37,
3,    CWB,    38,    37,    17,
3,   CWT,    12,    39,    41,
3,   CWT,    39,    16,    40,
3,   CWT,    41,    40,    17,
3,   CWT,     2,    42,    43,
3,   CWT,    42,     8,    18,
3,   CWT,    43,    18,     6,
3,   CWT,     6,    20,    45,
3,   CWT,    20,     7,    44,
3,   CWT,    45,    44,     0,
3,   CWT,     8,    46,    19,
3,   CWT,    46,     4,    47,
3,   CWT,    19,    47,     7,
3,    CWB,     3,    48,    49,
3,    CWB,    48,    10,    21,
3,    CWB,    49,    21,     9,
3,    CWB,     9,    23,    50,
3,    CWB,    23,     7,    47,
3,    CWB,    50,    47,     4,
3,    CWB,    10,    51,    22,
3,    CWB,    51,     0,    44,
3,    CWB,    22,    44,     7,
3,   CWT,     2,    52,    42,
3,   CWT,    52,    12,    24,
3,   CWT,    42,    24,     8,
3,   CWT,     8,    26,    46,
3,   CWT,    26,    11,    53,
3,   CWT,    46,    53,     4,
3,   CWT,    12,    54,    25,
3,   CWT,    54,     1,    55,
3,   CWT,    25,    55,    11,
3,    CWB,     3,    49,    56,
3,    CWB,    49,     9,    27,
3,    CWB,    56,    27,    13,
3,    CWB,    13,    29,    57,
3,    CWB,    29,    11,    55,
3,    CWB,    57,    55,     1,
3,    CWB,     9,    50,    28,
3,    CWB,    50,     4,    53,
3,    CWB,    28,    53,    11,
3,    CWB,     3,    58,    48,
3,    CWB,    58,    15,    30,
3,    CWB,    48,    30,    10,
3,    CWB,    10,    32,    51,
3,    CWB,    32,    14,    59,
3,    CWB,    51,    59,     0,
3,    CWB,    15,    60,    31,
3,    CWB,    60,     5,    61,
3,    CWB,    31,    61,    14,
3,   CWT,     2,    43,    62,
3,   CWT,    43,     6,    33,
3,   CWT,    62,    33,    16,
3,   CWT,    16,    35,    63,
3,   CWT,    35,    14,    61,
3,   CWT,    63,    61,     5,
3,   CWT,     6,    45,    34,
3,   CWT,    45,     0,    59,
3,   CWT,    34,    59,    14,
3,    CWB,     3,    56,    58,
3,    CWB,    56,    13,    36,
3,    CWB,    58,    36,    15,
3,    CWB,    15,    38,    60,
3,    CWB,    38,    17,    64,
3,    CWB,    60,    64,     5,
3,    CWB,    13,    57,    37,
3,    CWB,    57,     1,    65,
3,    CWB,    37,    65,    17,
3,   CWT,     2,    62,    52,
3,   CWT,    62,    16,    39,
3,   CWT,    52,    39,    12,
3,   CWT,    12,    41,    54,
3,   CWT,    41,    17,    65,
3,   CWT,    54,    65,     1,
3,   CWT,    16,    63,    40,
3,   CWT,    63,     5,    64,
3,   CWT,    40,    64,    17, };

BYTE BallFaceRed[] = { 
3,   CRT,    18,    19,    20,
3,   CRB,    21,    22,    23,
3,   CRT,    24,    25,    26,
3,    CRB,    27,    28,    29,
3,    CRB,    30,    31,    32,
3,   CRT,    33,    34,    35,
3,    CRB,    36,    37,    38,
3,   CRT,    39,    40,    41,
3,   CRT,    42,    18,    43,
3,   CRT,    20,    44,    45,
3,   CRT,    46,    47,    19,
3,    CRB,    48,    21,    49,
3,    CRB,    23,    47,    50,
3,    CRB,    51,    44,    22,
3,   CRT,    52,    24,    42,
3,   CRT,    26,    53,    46,
3,   CRT,    54,    55,    25,
3,    CRB,    49,    27,    56,
3,    CRB,    29,    55,    57,
3,    CRB,    50,    53,    28,
3,    CRB,    58,    30,    48,
3,    CRB,    32,    59,    51,
3,    CRB,    60,    61,    31,
3,   CRT,    43,    33,    62,
3,   CRT,    35,    61,    63,
3,   CRT,    45,    59,    34,
3,    CRB,    56,    36,    58,
3,    CRB,    38,    64,    60,
3,    CRB,    57,    65,    37,
3,   CRT,    62,    39,    52,
3,   CRT,    41,    65,    54,
3,   CRT,    63,    64,    40,
3,   CRT,     6,    18,    20,
3,   CRT,    18,     8,    19,
3,   CRT,    20,    19,     7,
3,    CRB,     9,    21,    23,
3,    CRB,    21,    10,    22,
3,    CRB,    23,    22,     7,
3,   CRT,     8,    24,    26,
3,   CRT,    24,    12,    25,
3,   CRT,    26,    25,    11,
3,    CRB,    13,    27,    29,
3,    CRB,    27,     9,    28,
3,    CRB,    29,    28,    11,
3,    CRB,    10,    30,    32,
3,    CRB,    30,    15,    31,
3,    CRB,    32,    31,    14,
3,   CRT,    16,    33,    35,
3,   CRT,    33,     6,    34,
3,   CRT,    35,    34,    14,
3,    CRB,    15,    36,    38,
3,    CRB,    36,    13,    37,
3,    CRB,    38,    37,    17,
3,   CRT,    12,    39,    41,
3,   CRT,    39,    16,    40,
3,   CRT,    41,    40,    17,
3,   CRT,     2,    42,    43,
3,   CRT,    42,     8,    18,
3,   CRT,    43,    18,     6,
3,   CRT,     6,    20,    45,
3,   CRT,    20,     7,    44,
3,   CRT,    45,    44,     0,
3,   CRT,     8,    46,    19,
3,   CRT,    46,     4,    47,
3,   CRT,    19,    47,     7,
3,    CRB,     3,    48,    49,
3,    CRB,    48,    10,    21,
3,    CRB,    49,    21,     9,
3,    CRB,     9,    23,    50,
3,    CRB,    23,     7,    47,
3,    CRB,    50,    47,     4,
3,    CRB,    10,    51,    22,
3,    CRB,    51,     0,    44,
3,    CRB,    22,    44,     7,
3,   CRT,     2,    52,    42,
3,   CRT,    52,    12,    24,
3,   CRT,    42,    24,     8,
3,   CRT,     8,    26,    46,
3,   CRT,    26,    11,    53,
3,   CRT,    46,    53,     4,
3,   CRT,    12,    54,    25,
3,   CRT,    54,     1,    55,
3,   CRT,    25,    55,    11,
3,    CRB,     3,    49,    56,
3,    CRB,    49,     9,    27,
3,    CRB,    56,    27,    13,
3,    CRB,    13,    29,    57,
3,    CRB,    29,    11,    55,
3,    CRB,    57,    55,     1,
3,    CRB,     9,    50,    28,
3,    CRB,    50,     4,    53,
3,    CRB,    28,    53,    11,
3,    CRB,     3,    58,    48,
3,    CRB,    58,    15,    30,
3,    CRB,    48,    30,    10,
3,    CRB,    10,    32,    51,
3,    CRB,    32,    14,    59,
3,    CRB,    51,    59,     0,
3,    CRB,    15,    60,    31,
3,    CRB,    60,     5,    61,
3,    CRB,    31,    61,    14,
3,   CRT,     2,    43,    62,
3,   CRT,    43,     6,    33,
3,   CRT,    62,    33,    16,
3,   CRT,    16,    35,    63,
3,   CRT,    35,    14,    61,
3,   CRT,    63,    61,     5,
3,   CRT,     6,    45,    34,
3,   CRT,    45,     0,    59,
3,   CRT,    34,    59,    14,
3,    CRB,     3,    56,    58,
3,    CRB,    56,    13,    36,
3,    CRB,    58,    36,    15,
3,    CRB,    15,    38,    60,
3,    CRB,    38,    17,    64,
3,    CRB,    60,    64,     5,
3,    CRB,    13,    57,    37,
3,    CRB,    57,     1,    65,
3,    CRB,    37,    65,    17,
3,   CRT,     2,    62,    52,
3,   CRT,    62,    16,    39,
3,   CRT,    52,    39,    12,
3,   CRT,    12,    41,    54,
3,   CRT,    41,    17,    65,
3,   CRT,    54,    65,     1,
3,   CRT,    16,    63,    40,
3,   CRT,    63,     5,    64,
3,   CRT,    40,    64,    17, };

BYTE BallFaceYellow[] = { 
3,   CYT,    18,    19,    20,
3,   CYB,    21,    22,    23,
3,   CYT,    24,    25,    26,
3,    CYB,    27,    28,    29,
3,    CYB,    30,    31,    32,
3,   CYT,    33,    34,    35,
3,    CYB,    36,    37,    38,
3,   CYT,    39,    40,    41,
3,   CYT,    42,    18,    43,
3,   CYT,    20,    44,    45,
3,   CYT,    46,    47,    19,
3,    CYB,    48,    21,    49,
3,    CYB,    23,    47,    50,
3,    CYB,    51,    44,    22,
3,   CYT,    52,    24,    42,
3,   CYT,    26,    53,    46,
3,   CYT,    54,    55,    25,
3,    CYB,    49,    27,    56,
3,    CYB,    29,    55,    57,
3,    CYB,    50,    53,    28,
3,    CYB,    58,    30,    48,
3,    CYB,    32,    59,    51,
3,    CYB,    60,    61,    31,
3,   CYT,    43,    33,    62,
3,   CYT,    35,    61,    63,
3,   CYT,    45,    59,    34,
3,    CYB,    56,    36,    58,
3,    CYB,    38,    64,    60,
3,    CYB,    57,    65,    37,
3,   CYT,    62,    39,    52,
3,   CYT,    41,    65,    54,
3,   CYT,    63,    64,    40,
3,   CYT,     6,    18,    20,
3,   CYT,    18,     8,    19,
3,   CYT,    20,    19,     7,
3,    CYB,     9,    21,    23,
3,    CYB,    21,    10,    22,
3,    CYB,    23,    22,     7,
3,   CYT,     8,    24,    26,
3,   CYT,    24,    12,    25,
3,   CYT,    26,    25,    11,
3,    CYB,    13,    27,    29,
3,    CYB,    27,     9,    28,
3,    CYB,    29,    28,    11,
3,    CYB,    10,    30,    32,
3,    CYB,    30,    15,    31,
3,    CYB,    32,    31,    14,
3,   CYT,    16,    33,    35,
3,   CYT,    33,     6,    34,
3,   CYT,    35,    34,    14,
3,    CYB,    15,    36,    38,
3,    CYB,    36,    13,    37,
3,    CYB,    38,    37,    17,
3,   CYT,    12,    39,    41,
3,   CYT,    39,    16,    40,
3,   CYT,    41,    40,    17,
3,   CYT,     2,    42,    43,
3,   CYT,    42,     8,    18,
3,   CYT,    43,    18,     6,
3,   CYT,     6,    20,    45,
3,   CYT,    20,     7,    44,
3,   CYT,    45,    44,     0,
3,   CYT,     8,    46,    19,
3,   CYT,    46,     4,    47,
3,   CYT,    19,    47,     7,
3,    CYB,     3,    48,    49,
3,    CYB,    48,    10,    21,
3,    CYB,    49,    21,     9,
3,    CYB,     9,    23,    50,
3,    CYB,    23,     7,    47,
3,    CYB,    50,    47,     4,
3,    CYB,    10,    51,    22,
3,    CYB,    51,     0,    44,
3,    CYB,    22,    44,     7,
3,   CYT,     2,    52,    42,
3,   CYT,    52,    12,    24,
3,   CYT,    42,    24,     8,
3,   CYT,     8,    26,    46,
3,   CYT,    26,    11,    53,
3,   CYT,    46,    53,     4,
3,   CYT,    12,    54,    25,
3,   CYT,    54,     1,    55,
3,   CYT,    25,    55,    11,
3,    CYB,     3,    49,    56,
3,    CYB,    49,     9,    27,
3,    CYB,    56,    27,    13,
3,    CYB,    13,    29,    57,
3,    CYB,    29,    11,    55,
3,    CYB,    57,    55,     1,
3,    CYB,     9,    50,    28,
3,    CYB,    50,     4,    53,
3,    CYB,    28,    53,    11,
3,    CYB,     3,    58,    48,
3,    CYB,    58,    15,    30,
3,    CYB,    48,    30,    10,
3,    CYB,    10,    32,    51,
3,    CYB,    32,    14,    59,
3,    CYB,    51,    59,     0,
3,    CYB,    15,    60,    31,
3,    CYB,    60,     5,    61,
3,    CYB,    31,    61,    14,
3,   CYT,     2,    43,    62,
3,   CYT,    43,     6,    33,
3,   CYT,    62,    33,    16,
3,   CYT,    16,    35,    63,
3,   CYT,    35,    14,    61,
3,   CYT,    63,    61,     5,
3,   CYT,     6,    45,    34,
3,   CYT,    45,     0,    59,
3,   CYT,    34,    59,    14,
3,    CYB,     3,    56,    58,
3,    CYB,    56,    13,    36,
3,    CYB,    58,    36,    15,
3,    CYB,    15,    38,    60,
3,    CYB,    38,    17,    64,
3,    CYB,    60,    64,     5,
3,    CYB,    13,    57,    37,
3,    CYB,    57,     1,    65,
3,    CYB,    37,    65,    17,
3,   CYT,     2,    62,    52,
3,   CYT,    62,    16,    39,
3,   CYT,    52,    39,    12,
3,   CYT,    12,    41,    54,
3,   CYT,    41,    17,    65,
3,   CYT,    54,    65,     1,
3,   CYT,    16,    63,    40,
3,   CYT,    63,     5,    64,
3,   CYT,    40,    64,    17, };

BYTE BallFaceGreen[] = { 
3,   CGT,    18,    19,    20,
3,   CGB,    21,    22,    23,
3,   CGT,    24,    25,    26,
3,    CGB,    27,    28,    29,
3,    CGB,    30,    31,    32,
3,   CGT,    33,    34,    35,
3,    CGB,    36,    37,    38,
3,   CGT,    39,    40,    41,
3,   CGT,    42,    18,    43,
3,   CGT,    20,    44,    45,
3,   CGT,    46,    47,    19,
3,    CGB,    48,    21,    49,
3,    CGB,    23,    47,    50,
3,    CGB,    51,    44,    22,
3,   CGT,    52,    24,    42,
3,   CGT,    26,    53,    46,
3,   CGT,    54,    55,    25,
3,    CGB,    49,    27,    56,
3,    CGB,    29,    55,    57,
3,    CGB,    50,    53,    28,
3,    CGB,    58,    30,    48,
3,    CGB,    32,    59,    51,
3,    CGB,    60,    61,    31,
3,   CGT,    43,    33,    62,
3,   CGT,    35,    61,    63,
3,   CGT,    45,    59,    34,
3,    CGB,    56,    36,    58,
3,    CGB,    38,    64,    60,
3,    CGB,    57,    65,    37,
3,   CGT,    62,    39,    52,
3,   CGT,    41,    65,    54,
3,   CGT,    63,    64,    40,
3,   CGT,     6,    18,    20,
3,   CGT,    18,     8,    19,
3,   CGT,    20,    19,     7,
3,    CGB,     9,    21,    23,
3,    CGB,    21,    10,    22,
3,    CGB,    23,    22,     7,
3,   CGT,     8,    24,    26,
3,   CGT,    24,    12,    25,
3,   CGT,    26,    25,    11,
3,    CGB,    13,    27,    29,
3,    CGB,    27,     9,    28,
3,    CGB,    29,    28,    11,
3,    CGB,    10,    30,    32,
3,    CGB,    30,    15,    31,
3,    CGB,    32,    31,    14,
3,   CGT,    16,    33,    35,
3,   CGT,    33,     6,    34,
3,   CGT,    35,    34,    14,
3,    CGB,    15,    36,    38,
3,    CGB,    36,    13,    37,
3,    CGB,    38,    37,    17,
3,   CGT,    12,    39,    41,
3,   CGT,    39,    16,    40,
3,   CGT,    41,    40,    17,
3,   CGT,     2,    42,    43,
3,   CGT,    42,     8,    18,
3,   CGT,    43,    18,     6,
3,   CGT,     6,    20,    45,
3,   CGT,    20,     7,    44,
3,   CGT,    45,    44,     0,
3,   CGT,     8,    46,    19,
3,   CGT,    46,     4,    47,
3,   CGT,    19,    47,     7,
3,    CGB,     3,    48,    49,
3,    CGB,    48,    10,    21,
3,    CGB,    49,    21,     9,
3,    CGB,     9,    23,    50,
3,    CGB,    23,     7,    47,
3,    CGB,    50,    47,     4,
3,    CGB,    10,    51,    22,
3,    CGB,    51,     0,    44,
3,    CGB,    22,    44,     7,
3,   CGT,     2,    52,    42,
3,   CGT,    52,    12,    24,
3,   CGT,    42,    24,     8,
3,   CGT,     8,    26,    46,
3,   CGT,    26,    11,    53,
3,   CGT,    46,    53,     4,
3,   CGT,    12,    54,    25,
3,   CGT,    54,     1,    55,
3,   CGT,    25,    55,    11,
3,    CGB,     3,    49,    56,
3,    CGB,    49,     9,    27,
3,    CGB,    56,    27,    13,
3,    CGB,    13,    29,    57,
3,    CGB,    29,    11,    55,
3,    CGB,    57,    55,     1,
3,    CGB,     9,    50,    28,
3,    CGB,    50,     4,    53,
3,    CGB,    28,    53,    11,
3,    CGB,     3,    58,    48,
3,    CGB,    58,    15,    30,
3,    CGB,    48,    30,    10,
3,    CGB,    10,    32,    51,
3,    CGB,    32,    14,    59,
3,    CGB,    51,    59,     0,
3,    CGB,    15,    60,    31,
3,    CGB,    60,     5,    61,
3,    CGB,    31,    61,    14,
3,   CGT,     2,    43,    62,
3,   CGT,    43,     6,    33,
3,   CGT,    62,    33,    16,
3,   CGT,    16,    35,    63,
3,   CGT,    35,    14,    61,
3,   CGT,    63,    61,     5,
3,   CGT,     6,    45,    34,
3,   CGT,    45,     0,    59,
3,   CGT,    34,    59,    14,
3,    CGB,     3,    56,    58,
3,    CGB,    56,    13,    36,
3,    CGB,    58,    36,    15,
3,    CGB,    15,    38,    60,
3,    CGB,    38,    17,    64,
3,    CGB,    60,    64,     5,
3,    CGB,    13,    57,    37,
3,    CGB,    57,     1,    65,
3,    CGB,    37,    65,    17,
3,   CGT,     2,    62,    52,
3,   CGT,    62,    16,    39,
3,   CGT,    52,    39,    12,
3,   CGT,    12,    41,    54,
3,   CGT,    41,    17,    65,
3,   CGT,    54,    65,     1,
3,   CGT,    16,    63,    40,
3,   CGT,    63,     5,    64,
3,   CGT,    40,    64,    17, };

BYTE BallFaceBrown[] = { 
3,   CBRT,    18,    19,    20,
3,   CBRB,    21,    22,    23,
3,   CBRT,    24,    25,    26,
3,    CBRB,    27,    28,    29,
3,    CBRB,    30,    31,    32,
3,   CBRT,    33,    34,    35,
3,    CBRB,    36,    37,    38,
3,   CBRT,    39,    40,    41,
3,   CBRT,    42,    18,    43,
3,   CBRT,    20,    44,    45,
3,   CBRT,    46,    47,    19,
3,    CBRB,    48,    21,    49,
3,    CBRB,    23,    47,    50,
3,    CBRB,    51,    44,    22,
3,   CBRT,    52,    24,    42,
3,   CBRT,    26,    53,    46,
3,   CBRT,    54,    55,    25,
3,    CBRB,    49,    27,    56,
3,    CBRB,    29,    55,    57,
3,    CBRB,    50,    53,    28,
3,    CBRB,    58,    30,    48,
3,    CBRB,    32,    59,    51,
3,    CBRB,    60,    61,    31,
3,   CBRT,    43,    33,    62,
3,   CBRT,    35,    61,    63,
3,   CBRT,    45,    59,    34,
3,    CBRB,    56,    36,    58,
3,    CBRB,    38,    64,    60,
3,    CBRB,    57,    65,    37,
3,   CBRT,    62,    39,    52,
3,   CBRT,    41,    65,    54,
3,   CBRT,    63,    64,    40,
3,   CBRT,     6,    18,    20,
3,   CBRT,    18,     8,    19,
3,   CBRT,    20,    19,     7,
3,    CBRB,     9,    21,    23,
3,    CBRB,    21,    10,    22,
3,    CBRB,    23,    22,     7,
3,   CBRT,     8,    24,    26,
3,   CBRT,    24,    12,    25,
3,   CBRT,    26,    25,    11,
3,    CBRB,    13,    27,    29,
3,    CBRB,    27,     9,    28,
3,    CBRB,    29,    28,    11,
3,    CBRB,    10,    30,    32,
3,    CBRB,    30,    15,    31,
3,    CBRB,    32,    31,    14,
3,   CBRT,    16,    33,    35,
3,   CBRT,    33,     6,    34,
3,   CBRT,    35,    34,    14,
3,    CBRB,    15,    36,    38,
3,    CBRB,    36,    13,    37,
3,    CBRB,    38,    37,    17,
3,   CBRT,    12,    39,    41,
3,   CBRT,    39,    16,    40,
3,   CBRT,    41,    40,    17,
3,   CBRT,     2,    42,    43,
3,   CBRT,    42,     8,    18,
3,   CBRT,    43,    18,     6,
3,   CBRT,     6,    20,    45,
3,   CBRT,    20,     7,    44,
3,   CBRT,    45,    44,     0,
3,   CBRT,     8,    46,    19,
3,   CBRT,    46,     4,    47,
3,   CBRT,    19,    47,     7,
3,    CBRB,     3,    48,    49,
3,    CBRB,    48,    10,    21,
3,    CBRB,    49,    21,     9,
3,    CBRB,     9,    23,    50,
3,    CBRB,    23,     7,    47,
3,    CBRB,    50,    47,     4,
3,    CBRB,    10,    51,    22,
3,    CBRB,    51,     0,    44,
3,    CBRB,    22,    44,     7,
3,   CBRT,     2,    52,    42,
3,   CBRT,    52,    12,    24,
3,   CBRT,    42,    24,     8,
3,   CBRT,     8,    26,    46,
3,   CBRT,    26,    11,    53,
3,   CBRT,    46,    53,     4,
3,   CBRT,    12,    54,    25,
3,   CBRT,    54,     1,    55,
3,   CBRT,    25,    55,    11,
3,    CBRB,     3,    49,    56,
3,    CBRB,    49,     9,    27,
3,    CBRB,    56,    27,    13,
3,    CBRB,    13,    29,    57,
3,    CBRB,    29,    11,    55,
3,    CBRB,    57,    55,     1,
3,    CBRB,     9,    50,    28,
3,    CBRB,    50,     4,    53,
3,    CBRB,    28,    53,    11,
3,    CBRB,     3,    58,    48,
3,    CBRB,    58,    15,    30,
3,    CBRB,    48,    30,    10,
3,    CBRB,    10,    32,    51,
3,    CBRB,    32,    14,    59,
3,    CBRB,    51,    59,     0,
3,    CBRB,    15,    60,    31,
3,    CBRB,    60,     5,    61,
3,    CBRB,    31,    61,    14,
3,   CBRT,     2,    43,    62,
3,   CBRT,    43,     6,    33,
3,   CBRT,    62,    33,    16,
3,   CBRT,    16,    35,    63,
3,   CBRT,    35,    14,    61,
3,   CBRT,    63,    61,     5,
3,   CBRT,     6,    45,    34,
3,   CBRT,    45,     0,    59,
3,   CBRT,    34,    59,    14,
3,    CBRB,     3,    56,    58,
3,    CBRB,    56,    13,    36,
3,    CBRB,    58,    36,    15,
3,    CBRB,    15,    38,    60,
3,    CBRB,    38,    17,    64,
3,    CBRB,    60,    64,     5,
3,    CBRB,    13,    57,    37,
3,    CBRB,    57,     1,    65,
3,    CBRB,    37,    65,    17,
3,   CBRT,     2,    62,    52,
3,   CBRT,    62,    16,    39,
3,   CBRT,    52,    39,    12,
3,   CBRT,    12,    41,    54,
3,   CBRT,    41,    17,    65,
3,   CBRT,    54,    65,     1,
3,   CBRT,    16,    63,    40,
3,   CBRT,    63,     5,    64,
3,   CBRT,    40,    64,    17, };

BYTE BallFaceBlue[] = { 
3,   CBLT,    18,    19,    20,
3,   CBLB,    21,    22,    23,
3,   CBLT,    24,    25,    26,
3,    CBLB,    27,    28,    29,
3,    CBLB,    30,    31,    32,
3,   CBLT,    33,    34,    35,
3,    CBLB,    36,    37,    38,
3,   CBLT,    39,    40,    41,
3,   CBLT,    42,    18,    43,
3,   CBLT,    20,    44,    45,
3,   CBLT,    46,    47,    19,
3,    CBLB,    48,    21,    49,
3,    CBLB,    23,    47,    50,
3,    CBLB,    51,    44,    22,
3,   CBLT,    52,    24,    42,
3,   CBLT,    26,    53,    46,
3,   CBLT,    54,    55,    25,
3,    CBLB,    49,    27,    56,
3,    CBLB,    29,    55,    57,
3,    CBLB,    50,    53,    28,
3,    CBLB,    58,    30,    48,
3,    CBLB,    32,    59,    51,
3,    CBLB,    60,    61,    31,
3,   CBLT,    43,    33,    62,
3,   CBLT,    35,    61,    63,
3,   CBLT,    45,    59,    34,
3,    CBLB,    56,    36,    58,
3,    CBLB,    38,    64,    60,
3,    CBLB,    57,    65,    37,
3,   CBLT,    62,    39,    52,
3,   CBLT,    41,    65,    54,
3,   CBLT,    63,    64,    40,
3,   CBLT,     6,    18,    20,
3,   CBLT,    18,     8,    19,
3,   CBLT,    20,    19,     7,
3,    CBLB,     9,    21,    23,
3,    CBLB,    21,    10,    22,
3,    CBLB,    23,    22,     7,
3,   CBLT,     8,    24,    26,
3,   CBLT,    24,    12,    25,
3,   CBLT,    26,    25,    11,
3,    CBLB,    13,    27,    29,
3,    CBLB,    27,     9,    28,
3,    CBLB,    29,    28,    11,
3,    CBLB,    10,    30,    32,
3,    CBLB,    30,    15,    31,
3,    CBLB,    32,    31,    14,
3,   CBLT,    16,    33,    35,
3,   CBLT,    33,     6,    34,
3,   CBLT,    35,    34,    14,
3,    CBLB,    15,    36,    38,
3,    CBLB,    36,    13,    37,
3,    CBLB,    38,    37,    17,
3,   CBLT,    12,    39,    41,
3,   CBLT,    39,    16,    40,
3,   CBLT,    41,    40,    17,
3,   CBLT,     2,    42,    43,
3,   CBLT,    42,     8,    18,
3,   CBLT,    43,    18,     6,
3,   CBLT,     6,    20,    45,
3,   CBLT,    20,     7,    44,
3,   CBLT,    45,    44,     0,
3,   CBLT,     8,    46,    19,
3,   CBLT,    46,     4,    47,
3,   CBLT,    19,    47,     7,
3,    CBLB,     3,    48,    49,
3,    CBLB,    48,    10,    21,
3,    CBLB,    49,    21,     9,
3,    CBLB,     9,    23,    50,
3,    CBLB,    23,     7,    47,
3,    CBLB,    50,    47,     4,
3,    CBLB,    10,    51,    22,
3,    CBLB,    51,     0,    44,
3,    CBLB,    22,    44,     7,
3,   CBLT,     2,    52,    42,
3,   CBLT,    52,    12,    24,
3,   CBLT,    42,    24,     8,
3,   CBLT,     8,    26,    46,
3,   CBLT,    26,    11,    53,
3,   CBLT,    46,    53,     4,
3,   CBLT,    12,    54,    25,
3,   CBLT,    54,     1,    55,
3,   CBLT,    25,    55,    11,
3,    CBLB,     3,    49,    56,
3,    CBLB,    49,     9,    27,
3,    CBLB,    56,    27,    13,
3,    CBLB,    13,    29,    57,
3,    CBLB,    29,    11,    55,
3,    CBLB,    57,    55,     1,
3,    CBLB,     9,    50,    28,
3,    CBLB,    50,     4,    53,
3,    CBLB,    28,    53,    11,
3,    CBLB,     3,    58,    48,
3,    CBLB,    58,    15,    30,
3,    CBLB,    48,    30,    10,
3,    CBLB,    10,    32,    51,
3,    CBLB,    32,    14,    59,
3,    CBLB,    51,    59,     0,
3,    CBLB,    15,    60,    31,
3,    CBLB,    60,     5,    61,
3,    CBLB,    31,    61,    14,
3,   CBLT,     2,    43,    62,
3,   CBLT,    43,     6,    33,
3,   CBLT,    62,    33,    16,
3,   CBLT,    16,    35,    63,
3,   CBLT,    35,    14,    61,
3,   CBLT,    63,    61,     5,
3,   CBLT,     6,    45,    34,
3,   CBLT,    45,     0,    59,
3,   CBLT,    34,    59,    14,
3,    CBLB,     3,    56,    58,
3,    CBLB,    56,    13,    36,
3,    CBLB,    58,    36,    15,
3,    CBLB,    15,    38,    60,
3,    CBLB,    38,    17,    64,
3,    CBLB,    60,    64,     5,
3,    CBLB,    13,    57,    37,
3,    CBLB,    57,     1,    65,
3,    CBLB,    37,    65,    17,
3,   CBLT,     2,    62,    52,
3,   CBLT,    62,    16,    39,
3,   CBLT,    52,    39,    12,
3,   CBLT,    12,    41,    54,
3,   CBLT,    41,    17,    65,
3,   CBLT,    54,    65,     1,
3,   CBLT,    16,    63,    40,
3,   CBLT,    63,     5,    64,
3,   CBLT,    40,    64,    17, };

BYTE BallFacePink[] = { 
3,   CPT,    18,    19,    20,
3,   CPB,    21,    22,    23,
3,   CPT,    24,    25,    26,
3,    CPB,    27,    28,    29,
3,    CPB,    30,    31,    32,
3,   CPT,    33,    34,    35,
3,    CPB,    36,    37,    38,
3,   CPT,    39,    40,    41,
3,   CPT,    42,    18,    43,
3,   CPT,    20,    44,    45,
3,   CPT,    46,    47,    19,
3,    CPB,    48,    21,    49,
3,    CPB,    23,    47,    50,
3,    CPB,    51,    44,    22,
3,   CPT,    52,    24,    42,
3,   CPT,    26,    53,    46,
3,   CPT,    54,    55,    25,
3,    CPB,    49,    27,    56,
3,    CPB,    29,    55,    57,
3,    CPB,    50,    53,    28,
3,    CPB,    58,    30,    48,
3,    CPB,    32,    59,    51,
3,    CPB,    60,    61,    31,
3,   CPT,    43,    33,    62,
3,   CPT,    35,    61,    63,
3,   CPT,    45,    59,    34,
3,    CPB,    56,    36,    58,
3,    CPB,    38,    64,    60,
3,    CPB,    57,    65,    37,
3,   CPT,    62,    39,    52,
3,   CPT,    41,    65,    54,
3,   CPT,    63,    64,    40,
3,   CPT,     6,    18,    20,
3,   CPT,    18,     8,    19,
3,   CPT,    20,    19,     7,
3,    CPB,     9,    21,    23,
3,    CPB,    21,    10,    22,
3,    CPB,    23,    22,     7,
3,   CPT,     8,    24,    26,
3,   CPT,    24,    12,    25,
3,   CPT,    26,    25,    11,
3,    CPB,    13,    27,    29,
3,    CPB,    27,     9,    28,
3,    CPB,    29,    28,    11,
3,    CPB,    10,    30,    32,
3,    CPB,    30,    15,    31,
3,    CPB,    32,    31,    14,
3,   CPT,    16,    33,    35,
3,   CPT,    33,     6,    34,
3,   CPT,    35,    34,    14,
3,    CPB,    15,    36,    38,
3,    CPB,    36,    13,    37,
3,    CPB,    38,    37,    17,
3,   CPT,    12,    39,    41,
3,   CPT,    39,    16,    40,
3,   CPT,    41,    40,    17,
3,   CPT,     2,    42,    43,
3,   CPT,    42,     8,    18,
3,   CPT,    43,    18,     6,
3,   CPT,     6,    20,    45,
3,   CPT,    20,     7,    44,
3,   CPT,    45,    44,     0,
3,   CPT,     8,    46,    19,
3,   CPT,    46,     4,    47,
3,   CPT,    19,    47,     7,
3,    CPB,     3,    48,    49,
3,    CPB,    48,    10,    21,
3,    CPB,    49,    21,     9,
3,    CPB,     9,    23,    50,
3,    CPB,    23,     7,    47,
3,    CPB,    50,    47,     4,
3,    CPB,    10,    51,    22,
3,    CPB,    51,     0,    44,
3,    CPB,    22,    44,     7,
3,   CPT,     2,    52,    42,
3,   CPT,    52,    12,    24,
3,   CPT,    42,    24,     8,
3,   CPT,     8,    26,    46,
3,   CPT,    26,    11,    53,
3,   CPT,    46,    53,     4,
3,   CPT,    12,    54,    25,
3,   CPT,    54,     1,    55,
3,   CPT,    25,    55,    11,
3,    CPB,     3,    49,    56,
3,    CPB,    49,     9,    27,
3,    CPB,    56,    27,    13,
3,    CPB,    13,    29,    57,
3,    CPB,    29,    11,    55,
3,    CPB,    57,    55,     1,
3,    CPB,     9,    50,    28,
3,    CPB,    50,     4,    53,
3,    CPB,    28,    53,    11,
3,    CPB,     3,    58,    48,
3,    CPB,    58,    15,    30,
3,    CPB,    48,    30,    10,
3,    CPB,    10,    32,    51,
3,    CPB,    32,    14,    59,
3,    CPB,    51,    59,     0,
3,    CPB,    15,    60,    31,
3,    CPB,    60,     5,    61,
3,    CPB,    31,    61,    14,
3,   CPT,     2,    43,    62,
3,   CPT,    43,     6,    33,
3,   CPT,    62,    33,    16,
3,   CPT,    16,    35,    63,
3,   CPT,    35,    14,    61,
3,   CPT,    63,    61,     5,
3,   CPT,     6,    45,    34,
3,   CPT,    45,     0,    59,
3,   CPT,    34,    59,    14,
3,    CPB,     3,    56,    58,
3,    CPB,    56,    13,    36,
3,    CPB,    58,    36,    15,
3,    CPB,    15,    38,    60,
3,    CPB,    38,    17,    64,
3,    CPB,    60,    64,     5,
3,    CPB,    13,    57,    37,
3,    CPB,    57,     1,    65,
3,    CPB,    37,    65,    17,
3,   CPT,     2,    62,    52,
3,   CPT,    62,    16,    39,
3,   CPT,    52,    39,    12,
3,   CPT,    12,    41,    54,
3,   CPT,    41,    17,    65,
3,   CPT,    54,    65,     1,
3,   CPT,    16,    63,    40,
3,   CPT,    63,     5,    64,
3,   CPT,    40,    64,    17, };

BYTE BallFaceBlack[] = { 
3,   CBKT,    18,    19,    20,
3,   CBKB,    21,    22,    23,
3,   CBKT,    24,    25,    26,
3,    CBKB,    27,    28,    29,
3,    CBKB,    30,    31,    32,
3,   CBKT,    33,    34,    35,
3,    CBKB,    36,    37,    38,
3,   CBKT,    39,    40,    41,
3,   CBKT,    42,    18,    43,
3,   CBKT,    20,    44,    45,
3,   CBKT,    46,    47,    19,
3,    CBKB,    48,    21,    49,
3,    CBKB,    23,    47,    50,
3,    CBKB,    51,    44,    22,
3,   CBKT,    52,    24,    42,
3,   CBKT,    26,    53,    46,
3,   CBKT,    54,    55,    25,
3,    CBKB,    49,    27,    56,
3,    CBKB,    29,    55,    57,
3,    CBKB,    50,    53,    28,
3,    CBKB,    58,    30,    48,
3,    CBKB,    32,    59,    51,
3,    CBKB,    60,    61,    31,
3,   CBKT,    43,    33,    62,
3,   CBKT,    35,    61,    63,
3,   CBKT,    45,    59,    34,
3,    CBKB,    56,    36,    58,
3,    CBKB,    38,    64,    60,
3,    CBKB,    57,    65,    37,
3,   CBKT,    62,    39,    52,
3,   CBKT,    41,    65,    54,
3,   CBKT,    63,    64,    40,
3,   CBKT,     6,    18,    20,
3,   CBKT,    18,     8,    19,
3,   CBKT,    20,    19,     7,
3,    CBKB,     9,    21,    23,
3,    CBKB,    21,    10,    22,
3,    CBKB,    23,    22,     7,
3,   CBKT,     8,    24,    26,
3,   CBKT,    24,    12,    25,
3,   CBKT,    26,    25,    11,
3,    CBKB,    13,    27,    29,
3,    CBKB,    27,     9,    28,
3,    CBKB,    29,    28,    11,
3,    CBKB,    10,    30,    32,
3,    CBKB,    30,    15,    31,
3,    CBKB,    32,    31,    14,
3,   CBKT,    16,    33,    35,
3,   CBKT,    33,     6,    34,
3,   CBKT,    35,    34,    14,
3,    CBKB,    15,    36,    38,
3,    CBKB,    36,    13,    37,
3,    CBKB,    38,    37,    17,
3,   CBKT,    12,    39,    41,
3,   CBKT,    39,    16,    40,
3,   CBKT,    41,    40,    17,
3,   CBKT,     2,    42,    43,
3,   CBKT,    42,     8,    18,
3,   CBKT,    43,    18,     6,
3,   CBKT,     6,    20,    45,
3,   CBKT,    20,     7,    44,
3,   CBKT,    45,    44,     0,
3,   CBKT,     8,    46,    19,
3,   CBKT,    46,     4,    47,
3,   CBKT,    19,    47,     7,
3,    CBKB,     3,    48,    49,
3,    CBKB,    48,    10,    21,
3,    CBKB,    49,    21,     9,
3,    CBKB,     9,    23,    50,
3,    CBKB,    23,     7,    47,
3,    CBKB,    50,    47,     4,
3,    CBKB,    10,    51,    22,
3,    CBKB,    51,     0,    44,
3,    CBKB,    22,    44,     7,
3,   CBKT,     2,    52,    42,
3,   CBKT,    52,    12,    24,
3,   CBKT,    42,    24,     8,
3,   CBKT,     8,    26,    46,
3,   CBKT,    26,    11,    53,
3,   CBKT,    46,    53,     4,
3,   CBKT,    12,    54,    25,
3,   CBKT,    54,     1,    55,
3,   CBKT,    25,    55,    11,
3,    CBKB,     3,    49,    56,
3,    CBKB,    49,     9,    27,
3,    CBKB,    56,    27,    13,
3,    CBKB,    13,    29,    57,
3,    CBKB,    29,    11,    55,
3,    CBKB,    57,    55,     1,
3,    CBKB,     9,    50,    28,
3,    CBKB,    50,     4,    53,
3,    CBKB,    28,    53,    11,
3,    CBKB,     3,    58,    48,
3,    CBKB,    58,    15,    30,
3,    CBKB,    48,    30,    10,
3,    CBKB,    10,    32,    51,
3,    CBKB,    32,    14,    59,
3,    CBKB,    51,    59,     0,
3,    CBKB,    15,    60,    31,
3,    CBKB,    60,     5,    61,
3,    CBKB,    31,    61,    14,
3,   CBKT,     2,    43,    62,
3,   CBKT,    43,     6,    33,
3,   CBKT,    62,    33,    16,
3,   CBKT,    16,    35,    63,
3,   CBKT,    35,    14,    61,
3,   CBKT,    63,    61,     5,
3,   CBKT,     6,    45,    34,
3,   CBKT,    45,     0,    59,
3,   CBKT,    34,    59,    14,
3,    CBKB,     3,    56,    58,
3,    CBKB,    56,    13,    36,
3,    CBKB,    58,    36,    15,
3,    CBKB,    15,    38,    60,
3,    CBKB,    38,    17,    64,
3,    CBKB,    60,    64,     5,
3,    CBKB,    13,    57,    37,
3,    CBKB,    57,     1,    65,
3,    CBKB,    37,    65,    17,
3,   CBKT,     2,    62,    52,
3,   CBKT,    62,    16,    39,
3,   CBKT,    52,    39,    12,
3,   CBKT,    12,    41,    54,
3,   CBKT,    41,    17,    65,
3,   CBKT,    54,    65,     1,
3,   CBKT,    16,    63,    40,
3,   CBKT,    63,     5,    64,
3,   CBKT,    40,    64,    17, };

point_t ShadowPnt[]={
{ 0.0000, 0.0000, 26.0000 },
{ 9.9498, 0.0000, 24.0209 },
{ 18.3848, 0.0000, 18.3848 },
{ 24.0209, 0.0000, 9.9498 },
{ 26.0000, 0.0000, 0.0000 },
{ 24.0209, 0.0000, -9.9498 },
{ 18.3848, 0.0000, -18.3848 },
{ 9.9498, 0.0000, -24.0209 },
{ 0.0000, 0.0000, -26.0000 },
{ -9.9498, 0.0000, -24.0209 },
{ -18.3848, 0.0000, -18.3848 },
{ -24.0209, 0.0000, -9.9498 },
{ -26.0000, 0.0000, -0.0000 },
{ -24.0209, 0.0000, 9.9497 },
{ -18.3848, 0.0000, 18.3848 },
{ -9.9498, 0.0000, 24.0209 }, };
BYTE ShadowFace[] = { 16, CS, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 };

point_t CushionPnt0[]={
  { -HTS+PS, -20.0, -20.0 },
  { -HTS+PS, -20.0, +20.0 },
  { +HTS-PS, -20.0, +20.0 },
  { +HTS-PS, -20.0, -20.0 },
  { -HTS+PS, +20.0, -20.0 },
  { -HTS+PS, +20.0, +20.0 },
  { +HTS-PS, +20.0, +20.0 },
  { +HTS-PS, +20.0, -20.0 },
  
  { -HTS+120.0, +10.0, +40.0 },
  { +HTS-120.0, +10.0, +40.0 },
};
BYTE CushionFace0[] = { 4, CWB, 0,1,2,3 };
BYTE CushionLine0[] = { 0,1, 1,2, 2,3, 3,0, 
 4,5, 5,6, 6,7, 7,4, 
 0,4, 1,5, 2,6, 3,7,
 8, 9,
 1,8,
 2,9,
 5,8,
 6,9,
};

point_t CushionPnt1[]={
  { -HTS+PS, -20.0, -20.0 },
  { -HTS+PS, -20.0, +20.0 },
  { +HTS-PS, -20.0, +20.0 },
  { +HTS-PS, -20.0, -20.0 },
  { -HTS+PS, +20.0, -20.0 },
  { -HTS+PS, +20.0, +20.0 },
  { +HTS-PS, +20.0, +20.0 },
  { +HTS-PS, +20.0, -20.0 },

  { -HTS+PS+30.0, +10.0, -40.0 },
  { +HTS-PS-30.0, +10.0, -40.0 },
};
BYTE CushionLine1[] = { 0,1, 1,2, 2,3, 3,0, 
 4,5, 5,6, 6,7, 7,4, 
 0,4, 1,5, 2,6, 3,7,
 8, 9,
 4,8,
 7,9,
 0,8,
 3,9,
};

point_t CushionPnt2[]={
  { -20.0, -20.0, -HTS+PS },
  { +20.0, -20.0, -HTS+PS },
  { +20.0, -20.0, +HTS-PS },
  { -20.0, -20.0, +HTS-PS },
  { -20.0, +20.0, -HTS+PS },
  { +20.0, +20.0, -HTS+PS },
  { +20.0, +20.0, +HTS-PS },
  { -20.0, +20.0, +HTS-PS },
};
point_t CushionPnt3[]={
  { -20.0, -20.0, -HTS+PS },
  { +20.0, -20.0, -HTS+PS },
  { +20.0, -20.0, +HTS-PS },
  { -20.0, -20.0, +HTS-PS },
  { -20.0, +20.0, -HTS+PS },
  { +20.0, +20.0, -HTS+PS },
  { +20.0, +20.0, +HTS-PS },
  { -20.0, +20.0, +HTS-PS },
};
point_t CushionPnt4[]={
  { -20.0, -20.0, -HTS+PS },
  { +20.0, -20.0, -HTS+PS },
  { +20.0, -20.0, +HTS-PS },
  { -20.0, -20.0, +HTS-PS },
  { -20.0, +20.0, -HTS+PS },
  { +20.0, +20.0, -HTS+PS },
  { +20.0, +20.0, +HTS-PS },
  { -20.0, +20.0, +HTS-PS },
};
point_t CushionPnt5[]={
  { -20.0, -20.0, -HTS+PS },
  { +20.0, -20.0, -HTS+PS },
  { +20.0, -20.0, +HTS-PS },
  { -20.0, -20.0, +HTS-PS },
  { -20.0, +20.0, -HTS+PS },
  { +20.0, +20.0, -HTS+PS },
  { +20.0, +20.0, +HTS-PS },
  { -20.0, +20.0, +HTS-PS },
};

const OBJECT object[] = {
                    { 8, &STBPnt[0], 1, &STBFace[0], 2022.0f},
                    { 8, &STBPnt[0], 8, &STBLine[0], 2022.0f},
                    { 16, &ShadowPnt[0], 1, &ShadowFace[0], 27.0f}, 
                    { 66, &BallPnt[0], 128, &BallFaceWhite[0], 27.0f}, 
                    { 66, &BallPnt[0], 128, &BallFaceRed[0], 27.0f}, 
                    { 66, &BallPnt[0], 128, &BallFaceYellow[0], 27.0f}, 
                    { 66, &BallPnt[0], 128, &BallFaceGreen[0], 27.0f}, 
                    { 66, &BallPnt[0], 128, &BallFaceBrown[0], 27.0f}, 
                    { 66, &BallPnt[0], 128, &BallFaceBlue[0], 27.0f}, 
                    { 66, &BallPnt[0], 128, &BallFacePink[0], 27.0f}, 
                    { 66, &BallPnt[0], 128, &BallFaceBlack[0], 27.0f}, 
                    { 10, &CushionPnt0[0], 17, &CushionLine0[0], 65535.0f}, 
                    { 10, &CushionPnt1[0], 17, &CushionLine1[0], 65535.0f}, 
                    { 8, &CushionPnt2[0], 12, &CushionLine0[0], 65535.0f}, 
                    { 8, &CushionPnt3[0], 12, &CushionLine0[0], 65535.0f}, 
                    { 8, &CushionPnt4[0], 12, &CushionLine0[0], 65535.0f}, 
                    { 8, &CushionPnt5[0], 12, &CushionLine0[0], 65535.0f}, 
                  };

int VisibleObjects=0;
visibleobject VisibleObject[MAX_OBJECTS];

FILE *file;
const BYTE ClipCodeList[NUM_FRUSTUM_PLANES]={CLIP_LEFT, CLIP_RIGHT, CLIP_BOTTOM, CLIP_TOP};
BYTE ClippedPolygon[NUM_FRUSTUM_PLANES][MAX_POLY_VERTS];

BYTE Points; // number of points in object - set initially then increases as clipped points are added

char string[256];

const void debugstring() { file=fopen("log.txt","a"); fprintf(file,string); fclose(file); }

const void debug(const char* str) { sprintf(string,"%s\n",str); debugstring(); }

/*const void bb()
{
	for (int o=0; o!=sizeof(object)/sizeof(object[0]); ++o)
	{
		float sphere=0.0f;
		for (int p=0; p!=object[o].Points; ++p)
		{
			const float bs=sqrt((object[o].Point[p].x*object[o].Point[p].x) + (object[o].Point[p].y*object[o].Point[p].y) + (object[o].Point[p].z*object[o].Point[p].z));
			if (sphere<bs) sphere=bs;
			sprintf(string,"bb %i %i %f %f %f %f %f\n",o,p,object[o].Point[p].x,object[o].Point[p].y,object[o].Point[p].z, bs, sphere); debugstring();
		}
	}
}*/

const void Set_DIB_FOV()
{
  if (BMInfo.bmiHeader.biHeight > 0)
  {
    pDIB = (pDIBBase + (DIBHeight - 1) * DIBWidth);
    DIBPitch = -DIBWidth;
  }
  else
  {
    pDIB = pDIBBase;
    DIBPitch = DIBWidth;
  }

  xscreenscale = DIBWidth / FIELD_OF_VIEW;
  yscreenscale = DIBHeight / FIELD_OF_VIEW;
  maxscale = max(xscreenscale, yscreenscale);
  xcenter = (DIBWidth / 2.0f) - 0.5f;
  ycenter = (DIBHeight / 2.0f) + 0.5f;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM uParam, LPARAM lParam)
{
    switch (message) 
    {
    case WM_COMMAND:  // message: command from application menu
        switch (LOWORD(uParam)) 
        {
        case IDM_EXIT:
            DestroyWindow (hwnd);
            break;
        default:
            return (DefWindowProc(hwnd, message, uParam, lParam));
        }
        break;

    case WM_SIZE:   // window size changed
        if (uParam != SIZE_MINIMIZED) 
        {
          if (hDIBSection != 0) // Skip when this is called before the first DIB section is created
          {
            const HBITMAP holdDIBSection = hDIBSection; // Resize the DIB section to the new size
            BMInfo.bmiHeader.biWidth = (LOWORD(lParam) +3) & ~3;
            BMInfo.bmiHeader.biHeight = HIWORD(lParam);;

            hDIBSection = CreateDIBSection(GetDC(hwnd), (BITMAPINFO*)&BMInfo, DIB_RGB_COLORS, &pDIBBase, NULL, 0);
            if (hDIBSection) 
            {
              DIBWidth = BMInfo.bmiHeader.biWidth;
              DIBHeight = BMInfo.bmiHeader.biHeight;
              DeleteObject(holdDIBSection);
              Set_DIB_FOV();
            }
          } 
        }
        break;

    case WM_DESTROY:  // message: window being destroyed
        DeleteObject(hDIBSection);                     
        PostQuitMessage(0);
        break;

    default:
        return (DefWindowProc(hwnd, message, uParam, lParam)); // Passes it on if unproccessed
    }
    return 0;
}

const BOOL InitApp(const HINSTANCE hInstance)
{
  WNDCLASS  wc;
  wc.style         = CS_HREDRAW | CS_VREDRAW; // Fill in window class structure with parameters that describe the main window.
  wc.lpfnWndProc   = (WNDPROC)WndProc;
  wc.cbClsExtra    = wc.cbWndExtra = 0;
  wc.hInstance     = hInstance;
  wc.hIcon         = LoadIcon (hInstance, "Clip");
  wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
  wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
  wc.lpszMenuName  = wc.lpszClassName = "Clip";
  return RegisterClass(&wc); // Register the window class and return success/failure code.
}

const BOOL InitInst(const HINSTANCE hInstance, const int nCmdShow)
{
  RECT rctmp={0, 0, DIBWidth, DIBHeight};
  AdjustWindowRect(&rctmp, WS_OVERLAPPEDWINDOW, FALSE);

  const HWND hwnd = CreateWindow("Clip", "Clip", WS_OVERLAPPED|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_DLGFRAME /*WS_OVERLAPPEDWINDOW*/, GetSystemMetrics(SM_CXSCREEN) - (rctmp.right - rctmp.left), GetSystemMetrics(SM_CYSCREEN) - (rctmp.bottom - rctmp.top), rctmp.right - rctmp.left, rctmp.bottom - rctmp.top, NULL, NULL, hInstance, NULL);
  if (!hwnd)
  {
    return FALSE;
  }

  BMInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
  BMInfo.bmiHeader.biWidth = DIBWidth;
  BMInfo.bmiHeader.biHeight = DIBHeight;
  BMInfo.bmiHeader.biPlanes = 1;
  BMInfo.bmiHeader.biBitCount = 8;
  BMInfo.bmiHeader.biCompression = BI_RGB;
  BMInfo.bmiHeader.biSizeImage = BMInfo.bmiHeader.biXPelsPerMeter = BMInfo.bmiHeader.biYPelsPerMeter = 0;
  BMInfo.bmiHeader.biClrUsed = BMInfo.bmiHeader.biClrImportant = 256;

  const BYTE colour[]={
    0,0,0, 
    255,255,255, 
    0,128,0, 
    0,64,0, 
    255,255,255, // white
    128,128,128, 
    255,0,0, // red
    128,0,0, 
    255,255,0, // yellow
    128,128,0, 
    0,255,0, // green
    0,128,0, 
    210,105,30, // brown
    139,69,19,
    0,0,255,  // blue
    0,0,128,
    255,105,180, // pink
    255,20,147, 
    32,32,32,  // black
    16,16,16,
     };
  RGBQUAD palette[256];
  for (int c=0, i=0; i!=256; ++i, c+=3)
  {
    palette[i].rgbRed = colour[c]; palette[i].rgbGreen = colour[c+1]; palette[i].rgbBlue = colour[c+2]; palette[i].rgbReserved = 0;
  }
  memcpy(&BMInfo.bmiColors[0], &palette[0], sizeof(palette[0])*256);

  PalInfo.palVersion = 0x300;
  PalInfo.palNumEntries = 256;
  for (int i=0; i!=256; ++i)
  {
    PalInfo.palPalEntry[i].peRed = palette[i].rgbRed;
    PalInfo.palPalEntry[i].peGreen = palette[i].rgbGreen;
    PalInfo.palPalEntry[i].peBlue = palette[i].rgbBlue;
    PalInfo.palPalEntry[i].peFlags = PC_NOCOLLAPSE;
  }

  const HPALETTE log_palette = CreatePalette((LOGPALETTE*)&PalInfo); // create the palette
  const HDC hdc = GetDC(hwnd);
  SelectPalette(hdc, log_palette, FALSE); // select it for that DC
  RealizePalette(hdc); // realize a palette on that DC
  DeleteObject(log_palette); // delete palette handler

  hDIBSection = CreateDIBSection(hdc, (BITMAPINFO*)&BMInfo, DIB_RGB_COLORS, &pDIBBase, NULL, 0);
  if (!hDIBSection) 
  {
    return FALSE;
  }

  Set_DIB_FOV();

  ShowWindow(hwnd, nCmdShow); // Show the window

  ReleaseDC(hwnd, hdc);
  hwndOutput = hwnd;

  file=fopen("log.txt","w");
  sprintf(string,"bb %f\n",123.45); debugstring();
 
//  bb();

  return TRUE;
}

//int PointSetCnt, PointAddCnt, PointMinusCnt, DotProductCnt, CrossProductCnt, LineCnt, FillCnt, ProjectPointCnt, BoundingSphereCnt, RotateCnt, BackRotateVectorCnt, TransformPointCnt, DrawObjectCnt, ClassifyFaceCnt, AddPointCnt, ClipToPlaneCnt, ClipToFrustumCnt, ClipLineToFrustumCnt, DrawObjectsCnt, DrawLineObjectCnt, DrawLineObjectsCnt, DrawVisibleLineObjectsCnt, DrawVisiblePolygonObjectsCnt, PolyFacesViewerCnt, SetWorldspaceClipPlaneCnt, SetUpFrustumCnt, ClassifyPointCt, MovePointsOffScreenCnt, MovePointsOnScreenCnt, UpdateViewPosCnt, ClassifyPointCnt;

point_t PointSet(const float in1, const float in2, const float in3)
{
//  ++PointSetCnt;
	const point_t p = {in1, in2, in3};
	return p;
}
const point_t PointAdd(const point_t *in1, const point_t *in2)
{
//  ++PointAddCnt;
  const point_t p = {in1->x+in2->x, in1->y+in2->y, in1->z+in2->z};
  return p;
}
const point_t PointMinus(const point_t *in1, const point_t *in2)
{
//  ++PointMinusCnt;
  const point_t p = {in1->x-in2->x, in1->y-in2->y, in1->z-in2->z};
  return p;
}
const float DotProduct(const point_t *vec1, const point_t *vec2)
{
//  ++DotProductCnt;
	return (vec1->x * vec2->x) + (vec1->y * vec2->y) + (vec1->z * vec2->z);
}
const point_t CrossProduct(const point_t *in1, const point_t *in2)
{
//  ++CrossProductCnt;
  const point_t p = {(in1->y * in2->z) - (in1->z * in2->y), (in1->z * in2->x) - (in1->x * in2->z), (in1->x * in2->y) - (in1->y * in2->x)};
  return p;
}

//const void Plot(const int x, const int y, const BYTE colour) { *(pDIB + (DIBPitch * y) + x)=colour; }

const void Line(const int startx, const int starty, const int endx, const int endy, const BYTE colour)
{
//  ++LineCnt;
	float sx;
	int sy,ey,ex;
	if (startx<=endx)
	{
		sx=startx;
		ex=endx;
		sy=starty;
		ey=endy;
	}
	else
	{
		sx=endx;
		ex=startx;
		sy=endy;
		ey=starty;
	}
	int pitch,ydir,scy,ecy;
	if (sy<=ey)
	{
		pitch=DIBPitch;
		scy=sy;
		ecy=ey+1;
		ydir=1;
	}
	else
	{
		pitch=-DIBPitch;
		scy=sy+1;
		ecy=ey;
		ydir=-1;
	}
	const float xslope=fabs((ex-sx) / (ecy-scy));
	if (xslope <1.0f)
	{
		for (char *screen_line=(char *)pDIB + (sy*DIBPitch); scy!=ecy; scy+=ydir, sx+=xslope, screen_line+=pitch)
		{
		  *(screen_line + (int)sx)=colour;
		}
	}
	else
	{
		for (char *screen_line=(char *)pDIB + (sy*DIBPitch); scy!=ecy; scy+=ydir, sx+=xslope, screen_line+=pitch)
		{
			memset(screen_line+(int)sx,colour,xslope+1);
		}
	}
}

const void Fill(const point2D_t *point, const BYTE points, const BYTE colour)
{
//  ++FillCnt;
	int EdgeList[MAX_SCREEN_HEIGHT][2];
  memset(&EdgeList[0][0],0,sizeof(EdgeList[0][0])*DIBHeight);
  memset(&EdgeList[0][1],0,sizeof(EdgeList[0][0])*DIBHeight);

	int ymax=point[0].y;
	int ymin=point[0].y;

	for (int p=0, curr=points-1; p!=points; curr=p, ++p)
	{
    Line(point[p].x, point[p].y, point[curr].x, point[curr].y, colour);
    continue;

		float xs, xe;
		int edge, ys, ye;

		if (point[curr].y>point[p].y)
		{
			edge=0;
			xs=point[p].x;
			xe=point[curr].x;
			ys=point[p].y;
			ye=point[curr].y;
		}
		else
		{
			edge=1;
			xs=point[curr].x;
			xe=point[p].x;
			ys=point[curr].y;
			ye=point[p].y;
		}

		if (ye>ymax) ymax=ye;
		if (ys<ymin) ymin=ys;

		if (ys==ye)
		{
			if (xs<xe)
			{
        if (EdgeList[ys][0]==0) EdgeList[ys][0]=xs-1;
			}
			else
			{
       if (EdgeList[ys][1]==0) EdgeList[ys][1]=xs+1;
			}
		}
		else
		{
			const int ydiff=ye-ys;
			const float xdiff=xe-xs;
			const float xslope=xdiff/ydiff;

			for (; ys<ye; ++ys, xs+=xslope)
			{
				EdgeList[ys][edge]=xs;
			}
		}
	}

	for (char *screen_line=(char *)pDIB+(DIBPitch*ymin); ymin<ymax; ++ymin, screen_line+=DIBPitch)
	{
		if (EdgeList[ymin][0] <= EdgeList[ymin][1])
		{
			memset(screen_line + EdgeList[ymin][0], colour,EdgeList[ymin][1] - EdgeList[ymin][0] + 1);
		}
		else
		{
			memset(screen_line + EdgeList[ymin][1], colour,EdgeList[ymin][0] - EdgeList[ymin][1] + 1);
		}
	}
}

const point2D_t ProjectPoint(const point_t *pin)
{
//  ++ProjectPointCnt;
  const float zrecip = (1.0f / (pin->z+EPSILON)) * maxscale;
  point2D_t pout = { pin->x * zrecip + xcenter, DIBHeight - (pin->y * zrecip + ycenter) };

  if (pout.x <0) pout.x=0; else if (pout.x >DIBWidth-1) pout.x=DIBWidth-1;
  if (pout.y <0) pout.y=0; else if (pout.y >DIBHeight-1) pout.y=DIBHeight-1;

  return pout;
}

int ZCompare(const void *v1, const void *v2)
{
  const visibleobject *p1 = (visibleobject*)v1;
  const visibleobject *p2 = (visibleobject*)v2;
  if (p1->vdist < p2->vdist)
  {
    return 1;
  }
  else if (p1->vdist > p2->vdist)
  {
    return -1;
  }
  else
  {
    return 0;
  }
}

const int BoundingSphere(const point_t *location, const float Bounding_Sphere)
{
//  ++BoundingSphereCnt;
  int result=ALL_ON;
  for (int f=0; f!=NUM_FRUSTUM_PLANES; ++f)
  {
    const float dot = DotProduct(location, &frustumplanes[f].normal);
    if (dot+Bounding_Sphere<frustumplanes[f].distance)
    {
      return ALL_OFF;
    }
    if (dot-frustumplanes[f].distance<Bounding_Sphere)
    {
      result=INTERSECTING;
    }
  }
  return result;
}

const void Rotate(const point_t *dir, point_t *right, point_t *up, point_t *in)
{
//  ++RotateCnt;
  const float rs = sin(dir->x); // Set up the world-to-view rotation. Note: much of the work done in concatenating these matrices can be factored out, since it contributes nothing to the final result; multiply the three matrices together on paper to generate a minimum equation for each of the 9 final elements
  const float rc = cos(dir->x);
  const float ps = sin(dir->y);
  const float pc = cos(dir->y);
  const float ys = sin(dir->z);
  const float yc = cos(dir->z);

  const float mtemp2[3][3] ={ { rc * yc, rs, rc * -ys }, { (pc * -rs * yc) + (ps * ys), pc * rc, (pc * -rs * -ys) + (ps * yc) }, { (-ps * -rs * yc) + (pc * ys), -ps * rc, (-ps * -rs * -ys) + (pc * yc) } };

  *right = PointSet( mtemp2[0][0], mtemp2[0][1], mtemp2[0][2] ); // Break out the rotation matrix into vright, vup, and vpn. We could work directly with the matrix; breaking it out into three vectors is just to make things clearer
  *up = PointSet( mtemp2[1][0],mtemp2[1][1],mtemp2[1][2] );
  *in = PointSet( mtemp2[2][0], mtemp2[2][1], mtemp2[2][2] );
}

const void UpdateViewPos()
{
//  ++UpdateViewPosCnt;
  const point_t xaxis = {1, 0, 0};
  const point_t yaxis = {0, 1, 0};
  const point_t zaxis = {0, 0, 1};

  const point_t motionvec={DotProduct(&vpn, &xaxis), DotProduct(&vpn, &yaxis), DotProduct(&vpn, &zaxis)}; // Move in the view direction, across the x-y plane, as if walking. This approach moves slower when looking up or down at more of an angle

  const point_t temp_pos={ motionvec.x * currentspeed,  motionvec.y * currentspeed, motionvec.z * currentspeed};
  currentpos=PointAdd(&temp_pos, &currentpos);
  currentdir=PointAdd(&currentdir, &currentturnspeed);

  Rotate(&currentdir, &vright, &vup, &vpn);

  currentspeed = fabs(currentspeed) > EPSILON ? currentspeed *= FRICTION : 0.0f;
  currentdir.x = fabs(currentdir.x) > EPSILON ? currentdir.x *= FRICTION : 0.0f;
  currentturnspeed = PointSet(fabs(currentturnspeed.x) > EPSILON ? currentturnspeed.x *= FRICTION : 0.0f, fabs(currentturnspeed.y) > EPSILON ? currentturnspeed.y *= FRICTION : 0.0f, fabs(currentturnspeed.z) > EPSILON ? currentturnspeed.z *= FRICTION : 0.0f);
}

const point_t BackRotateVector(const point_t *pin) // Rotate a vector from viewspace to worldspace. // Rotate into the world orientation
{
//  ++BackRotateVectorCnt;
	const point_t p = { (pin->x * vright.x) + (pin->y * vup.x) + (pin->z * vpn.x), (pin->x * vright.y) + (pin->y * vup.y) + (pin->z * vpn.y), (pin->x * vright.z) + (pin->y * vup.z) + (pin->z * vpn.z) };
	return p;
}

const point_t TransformPoint(const point_t *pin) // Transform a point from worldspace to viewspace. // Translate into a viewpoint-relative coordinate
{
//  ++TransformPointCnt;
	const point_t tvert = PointMinus(pin, &currentpos);
	const point_t p={DotProduct(&tvert, &vright), DotProduct(&tvert, &vup), DotProduct(&tvert, &vpn) };
  return p;
}

const float PolyFacesViewer(const BYTE i0, const BYTE i1, const BYTE i2) // Returns true if polygon faces the viewpoint, assuming a clockwise winding of vertices as seen from the front.
{
//  ++PolyFacesViewerCnt;
	const point_t *p0=&Vertex[i0].Point;
	const point_t *p1=&Vertex[i1].Point;
	const point_t *p2=&Vertex[i2].Point;

  const point_t edge1=PointMinus(p0, p1);
  const point_t edge2=PointMinus(p2, p1);
	const point_t normal=CrossProduct(&edge1, &edge2);
  const point_t viewvec=PointMinus(p0, &currentpos);

  return DotProduct(&viewvec, &normal);
}

const plane_t SetWorldspaceClipPlane(const point_t *normal) // Set up a clip plane with the specified normal.
{
//  ++SetWorldspaceClipPlaneCnt;
  plane_t	plane;
  plane.normal=BackRotateVector(normal); // Rotate the plane normal into worldspace
  plane.distance = DotProduct(&currentpos, &plane.normal) + EPSILON;
  return plane;
}

const void SetUpFrustum() // Set up the planes of the frustum, in worldspace coordinates.
{
//  ++SetUpFrustumCnt;
  float angle = atan(2.0f / FIELD_OF_VIEW * maxscale / xscreenscale);
  float s = sin(angle);
  float c = cos(angle);

  point_t normal= { s, 0.0f, c}; // Left clip plane
  frustumplanes[0]=SetWorldspaceClipPlane(&normal);

  normal.x = -s; // Right clip plane
  frustumplanes[1]=SetWorldspaceClipPlane(&normal);

  angle = atan(2.0f / FIELD_OF_VIEW * maxscale / yscreenscale);
  s = sin(angle);
  c = cos(angle);

	normal= PointSet(0.0f ,s, c); // Bottom clip plane
  frustumplanes[2]=SetWorldspaceClipPlane(&normal);

  normal.y = -s; // Top clip plane
  frustumplanes[3]=SetWorldspaceClipPlane(&normal);
}

const BYTE ClassifyPoint(const point_t *point)
{
//  ++ClassifyPointCnt;
  BYTE clipcodeor=0;
  for (int f=0; f!=NUM_FRUSTUM_PLANES; ++f)
  {
    if (DotProduct(point, &frustumplanes[f].normal) <frustumplanes[f].distance)
    {
			clipcodeor |= ClipCodeList[f];
    }
  }
  return clipcodeor;
}

const BYTE MovePointsOffScreen(const point_t *point, const point_t *centre, const BYTE points, BYTE *ClipCodesOr)
{
//  ++MovePointsOffScreenCnt;
	*ClipCodesOr=0;
	BYTE clipcodesand=255;

 	for (int p=0; p!=points; ++p)
  {
   	Vertex[p].Point=PointSet(point[p].x+centre->x, point[p].y+centre->y, point[p].z+centre->z);
 	  Vertex[p].ClipCode=ClassifyPoint(&Vertex[p].Point);
 	  clipcodesand &= Vertex[p].ClipCode;
 	  *ClipCodesOr |= Vertex[p].ClipCode;
 	}
	return clipcodesand;
}

const void MovePointsOnScreen(const point_t *point, const point_t *centre, const BYTE points)
{
//  ++MovePointsOnScreenCnt;
 	for (int p=0; p!=points; ++p)
 	{
 		Vertex[p].Point=PointSet(point[p].x+centre->x, point[p].y+centre->y, point[p].z+centre->z);
 	}
}

const void DrawObject(const BYTE *visibleface, const int faces)
{
//  ++DrawObjectCnt;
	point2D_t project[MAX_POLY_VERTS];
	BOOL frame[MAX_POLY_VERTS];
  memset(&frame[0],FALSE,sizeof(frame[0])*Points);

  point2D_t polygon[MAX_POLY_VERTS];

  for (int pos=0, f=0, points; f!=faces; ++f)
	{
    points=visibleface[pos++];
	  const BYTE colour=visibleface[pos++];

		for (int fp=0; fp!=points; ++fp)
		{
      const BYTE index=visibleface[pos++];
      if (frame[index]==FALSE)
      {
        frame[index]=TRUE;
        const point_t transformed_point=TransformPoint(&Vertex[index].Point);
        project[index]=ProjectPoint(&transformed_point);
      }
      polygon[fp].x=project[index].x;
      polygon[fp].y=project[index].y;
		}
		Fill(&polygon[0], points, colour);
  }
}

const BYTE ClassifyFace(const BYTE *faceindex, const BYTE points, BYTE *ClipCodesOr)
{
//  ++ClassifyFaceCnt;
  *ClipCodesOr = 0;
  BYTE ClipCodesAnd = 255;
  for (int p=0; p!=points; ++p)
  {
    const BYTE vertex=faceindex[p];
    const BYTE clipflags=Vertex[vertex].ClipCode;
    ClipCodesAnd &= clipflags;
    *ClipCodesOr |= clipflags;
  }
  return ClipCodesAnd;
}

const BYTE AddPoint(const Point3D *in, const Point3D *out, const float scale)
{
//  ++AddPointCnt;
  Vertex[Points].Point.x = in->Point.x + ((out->Point.x - in->Point.x) * (scale-EPSILON));
  Vertex[Points].Point.y = in->Point.y + ((out->Point.y - in->Point.y) * (scale-EPSILON));
  Vertex[Points].Point.z = in->Point.z + ((out->Point.z - in->Point.z) * (scale-EPSILON));
  for (int i=0; i!=Points; ++i)
  {
    if ((fabs(Vertex[i].Point.x-Vertex[Points].Point.x)<EPSILON /*1.0f 2.0f 3.0f*/) && (fabs(Vertex[i].Point.y-Vertex[Points].Point.y)<EPSILON) && (fabs(Vertex[i].Point.z-Vertex[Points].Point.z)<EPSILON))
    {
      return i;
    }
  }
	Vertex[Points].ClipCode=ClassifyPoint(&Vertex[Points].Point);
  ++Points;
  return Points-1;
}

BYTE ClipToPlane(const BYTE *vertex_list_in, const int *vertex_count, const plane_t *pplane, BYTE *vertex_list_out, const BYTE clip_code)
{
//  ++ClipToPlaneCnt;
  BYTE vertex_out=0;
  float cur_dot = DotProduct(&Vertex[vertex_list_in[0]].Point, &pplane->normal);
  int cur_in = (cur_dot >= pplane->distance);
//int cur_in = Vertex[vertex_list_in[0]].ClipCode & clip_code;
  for (int i=0; i!=*vertex_count; ++i)
  {
    if (cur_in)
    {
      vertex_list_out[vertex_out++] = vertex_list_in[i];
    }
    const int nextvert = (i + 1) % *vertex_count;
    const float next_dot = DotProduct(&Vertex[vertex_list_in[nextvert]].Point, &pplane->normal);
    const int next_in = (next_dot >= pplane->distance);

    if (cur_in != next_in)
    {
      vertex_list_out[vertex_out++]=AddPoint(&Vertex[vertex_list_in[i]], &Vertex[vertex_list_in[nextvert]], (pplane->distance - cur_dot) / (next_dot - cur_dot));
    }
    cur_dot = next_dot;
    cur_in = next_in;
  }
  if (vertex_out <3) return 0;
  if (ClassifyFace(&vertex_list_out[0], vertex_out, &clip_code)!=0) return 0; // if all off one side
  return vertex_out;
}

BYTE *ClipToFrustum(BYTE *pin, int *vertex_count, const BYTE clip_codes_or)
{
//  ++ClipToFrustumCnt;
  BYTE *ppoly = pin;
  for (int f=0; f!=NUM_FRUSTUM_PLANES; ++f)
  {
    if ((clip_codes_or & ClipCodeList[f])!=0)
    {
      *vertex_count=ClipToPlane(ppoly, vertex_count, &frustumplanes[f], &ClippedPolygon[f][0], ClipCodeList[f]);
      if (*vertex_count==0) return NULL;
      ppoly = &ClippedPolygon[f][0];
    }
  }
  return ppoly;
}

const BOOL ClipLineToFrustum(BYTE *line_start, BYTE *line_end)
{
//  ++ClipLineToFrustumCnt;
  for (int f=0; f!=NUM_FRUSTUM_PLANES; ++f)
  {
    const float start_dot = DotProduct(&Vertex[*line_start].Point, &frustumplanes[f].normal);
    const float end_dot = DotProduct(&Vertex[*line_end].Point, &frustumplanes[f].normal);
    const int start_in = (start_dot >= frustumplanes[f].distance);
    const int end_in = (end_dot >= frustumplanes[f].distance);

    if (start_in!=end_in) // either is off edge
    {
      if (start_in==FALSE) // start is off edge
      {
        *line_start=AddPoint(&Vertex[*line_start], &Vertex[*line_end], (frustumplanes[f].distance - start_dot) / (end_dot - start_dot));
      }
      else // end is off edge
      {
        *line_end=AddPoint(&Vertex[*line_start], &Vertex[*line_end], (frustumplanes[f].distance - start_dot) / (end_dot - start_dot));
      }
    }
    else //  both the same
    {
      if (start_in==FALSE) // start is off edge
      {
        return FALSE;
      }
    }
  }
  return TRUE;
}

const void DrawObjects()
{
// ++DrawObjectsCnt;
	BYTE VisibleFace[MAX_OBJECT_POINTS]; // index into faces that need to be displayed

  for (int o=0; o!=VisibleObjects; ++o)
  {
    const BYTE type = VisibleObject[o].type;
	  if (VisibleObject[o].boundingsphere==INTERSECTING)
    {
      BYTE ClipCodesOr;
      if (MovePointsOffScreen(object[type].Point, &VisibleObject[o].center, object[type].Points, &ClipCodesOr)!=0) continue; // all off one side
      if (ClipCodesOr==0) VisibleObject[o].boundingsphere=ALL_ON; // nothing needs clipped
    }
    else
    {
    	MovePointsOnScreen(object[type].Point, &VisibleObject[o].center, object[type].Points); // all on screen
    }

    int Pos=0;
    int faces=0;
    Points=object[type].Points; // set initial number of points in object
    if (VisibleObject[o].boundingsphere==ALL_ON) // clip not needed
    {
      for (int pos=0, f=0; f!=object[type].Faces; ++f)
			{
			  const BYTE facepoints=object[type].Face[pos];
			  if (PolyFacesViewer(object[type].Face[pos+2], object[type].Face[pos+3], object[type].Face[pos+4])>=0.0f)
			  {
				  ++faces;					// add this face
				  memcpy(&VisibleFace[Pos], &object[type].Face[pos], (facepoints+2)*sizeof(VisibleFace[0])); // copy face indexes across
				  Pos+=(facepoints+2);
			  }
			  pos+=(facepoints+2);
			 }
    }
    else // clip needed
    {
      for (int pos=0, f=0, facepoints, newverts; f!=object[type].Faces; ++f, pos+=(facepoints+2))
			{
			  facepoints=newverts=object[type].Face[pos];
			  if (PolyFacesViewer(object[type].Face[pos+2], object[type].Face[pos+3], object[type].Face[pos+4])>=0.0f)
			  {
          BYTE* objectfacepos=&object[type].Face[pos]+2; // store position of face
          BYTE PolygonClipCodesOr;
          if ((ClassifyFace(objectfacepos, facepoints, &PolygonClipCodesOr)!=0)) continue; // if all off one side
          if (PolygonClipCodesOr!=0) // if face needs clipped
          {
            objectfacepos=ClipToFrustum(objectfacepos, &newverts, PolygonClipCodesOr); // clip face
            if (objectfacepos==NULL) continue; // if face fully clipped
          }
          ++faces;          // add this face
          VisibleFace[Pos++]=newverts; // copy new verts
          VisibleFace[Pos++]=object[type].Face[pos+1];  // copy colour
          memcpy(&VisibleFace[Pos], objectfacepos, newverts*sizeof(VisibleFace[0])); // copy face indexes
          Pos+=newverts; // inc pos by verts
				}
      }
    }
	  DrawObject(&VisibleFace[0], faces);
  }
  VisibleObjects=0;
}

const void DrawLineObject(const BYTE *visibleface, const int faces, const BYTE colour)
{
//  ++DrawLineObjectCnt;
  point2D_t project[MAX_POLY_VERTS];
  BOOL frame[MAX_POLY_VERTS];
  memset(&frame[0],FALSE,sizeof(frame[0])*Points);

  for (int p=0, l=0; l!=faces; ++l, p+=2)
  {
    for (int i=0; i!=2; ++i)
    {
      const BYTE idx=visibleface[p+i];
      if (frame[idx]==FALSE)
      {
        frame[idx]=TRUE;
        const point_t transformed_point=TransformPoint(&Vertex[idx].Point);
        project[idx]=ProjectPoint(&transformed_point);
      }
    }
    Line(project[visibleface[p]].x, project[visibleface[p]].y, project[visibleface[p+1]].x, project[visibleface[p+1]].y, colour);
  }
}

const void DrawLineObjects(const BYTE Type, const point_t *Centre, BYTE Boundingsphere, const BYTE Colour)
{
//  ++DrawLineObjectsCnt;
  if (Boundingsphere==INTERSECTING)
  {
    BYTE ClipCodesOr;
    if (MovePointsOffScreen(object[Type].Point, Centre, object[Type].Points, &ClipCodesOr)!=0) return; // all off one side
    if (ClipCodesOr==0) Boundingsphere=ALL_ON; // nothing needs clipped
  }
  else
  {
    MovePointsOnScreen(object[Type].Point, Centre, object[Type].Points); // all on screen
  }

  int faces=0;
  BYTE VisibleFace[MAX_OBJECT_POINTS]; // index into faces that need to be displayed
  Points=object[Type].Points; // set initial number of points in object
  if (Boundingsphere==ALL_ON) // clip not needed
  {
    faces=object[Type].Faces;
    memcpy(&VisibleFace[0], &object[Type].Face[0], sizeof(VisibleFace[0])*faces*2);
  }
  else // clip needed
  {
    for (int pos=0, p=0, l=0; l!=object[Type].Faces; ++l, p+=2)
    {
      BYTE line_s=object[Type].Face[p];
      BYTE line_e=object[Type].Face[p+1];
      const BYTE clip_s=Vertex[line_s].ClipCode;
      const BYTE clip_e=Vertex[line_e].ClipCode;
      if ((clip_s & clip_e)==0) // both not off same side
      {
        if ((clip_s | clip_e)==0) // both on
        {
          ++faces;
          memcpy(&VisibleFace[pos], &object[Type].Face[p], sizeof(VisibleFace[0])*2);
          pos+=2;
        }
        else
        {
          if (ClipLineToFrustum(&line_s, &line_e)==TRUE)
          {
            ++faces;
            VisibleFace[pos]=line_s;
            VisibleFace[pos+1]=line_e;
            pos+=2;
          }
        }
      }
    }
  }
  DrawLineObject(&VisibleFace[0], faces, Colour);
}

const void DrawVisibleLineObjects(const OBJECTS *objectlist, const int numobjects, const BYTE Colour)
{
//  ++DrawVisibleLineObjectsCnt; 
  for (int o=0; o!=numobjects; ++o)
  {
    const BYTE boundingsphere=BoundingSphere(&objectlist[o].Location, object[objectlist[o].Type].BoundingSphere);
    if (boundingsphere==ALL_OFF) continue;
    const point_t dist=PointMinus(&objectlist[o].Location, &currentpos);
    DrawLineObjects(objectlist[o].Type, &objectlist[o].Location, boundingsphere, Colour);
  }
}

const void DrawVisiblePolygonObjects(const OBJECTS *objectlist, const int numobjects)
{
//  ++DrawVisiblePolygonObjectsCnt;
  for (int o=0; o!=numobjects; ++o)
  {
    VisibleObject[VisibleObjects].boundingsphere=BoundingSphere(&objectlist[o].Location, object[objectlist[o].Type].BoundingSphere);
    if (VisibleObject[VisibleObjects].boundingsphere==ALL_OFF) continue;

    const point_t dist=PointMinus(&objectlist[o].Location, &currentpos);
    VisibleObject[VisibleObjects].type = objectlist[o].Type;
    VisibleObject[VisibleObjects].vdist = DotProduct(&dist, &dist);
    VisibleObject[VisibleObjects].center = PointSet( objectlist[o].Location.x, objectlist[o].Location.y, objectlist[o].Location.z );      
    ++VisibleObjects;
  }
}

/*const void OutputDebug()
{
  sprintf(string,"PointSetCnt %i\n",PointSetCnt); debugstring();
  sprintf(string,"PointAddCnt %i\n",PointAddCnt); debugstring();
  sprintf(string,"PointMinusCnt %i\n",PointMinusCnt); debugstring();
  sprintf(string,"DotProductCnt %i\n",DotProductCnt); debugstring();
  sprintf(string,"CrossProductCnt %i\n",CrossProductCnt); debugstring();
  sprintf(string,"LineCnt %i\n",LineCnt); debugstring();
  sprintf(string,"FillCnt %i\n",FillCnt); debugstring();
  sprintf(string,"ProjectPointCnt %i\n",ProjectPointCnt); debugstring();
  sprintf(string,"BoundingSphereCnt %i\n",BoundingSphereCnt); debugstring();
  sprintf(string,"RotateCnt %i\n",RotateCnt); debugstring();
  sprintf(string,"BackRotateVectorCnt %i\n",BackRotateVectorCnt); debugstring();
  sprintf(string,"TransformPointCnt %i\n",TransformPointCnt); debugstring();
  sprintf(string,"DrawObjectCnt %i\n",DrawObjectCnt); debugstring();
  sprintf(string,"ClassifyFaceCnt %i\n",ClassifyFaceCnt); debugstring();
  sprintf(string,"AddPointCnt %i\n",AddPointCnt); debugstring();
  sprintf(string,"ClipToPlaneCnt %i\n",ClipToPlaneCnt); debugstring();
  sprintf(string,"ClipToFrustumCnt %i\n",ClipToFrustumCnt); debugstring();
  sprintf(string,"ClipLineToFrustumCnt %i\n",ClipLineToFrustumCnt); debugstring();
  sprintf(string,"DrawObjectsCnt %i\n",DrawObjectsCnt); debugstring();
  sprintf(string,"DrawLineObjectCnt %i\n",DrawLineObjectCnt); debugstring();
  sprintf(string,"DrawLineObjectsCnt %i\n",DrawLineObjectsCnt); debugstring();
  sprintf(string,"DrawVisibleLineObjectsCnt %i\n",DrawVisibleLineObjectsCnt); debugstring();
  sprintf(string,"DrawVisiblePolygonObjectsCnt %i\n",DrawVisiblePolygonObjectsCnt); debugstring();
  sprintf(string,"PolyFacesViewerCnt %i\n",PolyFacesViewerCnt); debugstring();
  sprintf(string,"SetWorldspaceClipPlaneCnt %i\n",SetWorldspaceClipPlaneCnt); debugstring();
  sprintf(string,"SetUpFrustumCnt %i\n",SetUpFrustumCnt); debugstring();
  sprintf(string,"ClassifyPointCnt %i\n",ClassifyPointCnt); debugstring();
  sprintf(string,"MovePointsOffScreenCnt %i\n",MovePointsOffScreenCnt); debugstring();
  sprintf(string,"MovePointsOnScreenCnt %i\n",MovePointsOnScreenCnt); debugstring();
  sprintf(string,"UpdateViewPosCnt %i\n",UpdateViewPosCnt); debugstring();
  PointSetCnt=PointAddCnt=PointMinusCnt=DotProductCnt=CrossProductCnt=LineCnt=FillCnt=ProjectPointCnt=BoundingSphereCnt=
  RotateCnt=BackRotateVectorCnt=TransformPointCnt=DrawObjectCnt=ClassifyFaceCnt=AddPointCnt=ClipToPlaneCnt=ClipToFrustumCnt= 
  ClipLineToFrustumCnt=DrawObjectsCnt=DrawLineObjectCnt=DrawLineObjectsCnt=DrawVisibleLineObjectsCnt= 
  DrawVisiblePolygonObjectsCnt=PolyFacesViewerCnt=SetWorldspaceClipPlaneCnt=SetUpFrustumCnt=ClassifyPointCnt= 
  MovePointsOffScreenCnt=MovePointsOnScreenCnt=UpdateViewPosCnt=ClassifyPointCnt=0;
}*/

const void Input()
{
  if (GetAsyncKeyState(VK_UP)) currentturnspeed.y+=SPEED;    
  if (GetAsyncKeyState(VK_DOWN)) currentturnspeed.y-=SPEED;
  if (GetAsyncKeyState(VK_RIGHT)) currentturnspeed.z+=SPEED;
  if (GetAsyncKeyState(VK_LEFT)) currentturnspeed.z-=SPEED;
  if (GetAsyncKeyState('A')) currentspeed+=ACCEL;
  if (GetAsyncKeyState('Z')) currentspeed-=ACCEL;
//  if (GetAsyncKeyState('O')) OutputDebug();
}

const void UpdateWorld() // Render the current state of the world to the screen.
{
  const point_t p0 = { 0, 0, PS};
  const point_t p1 = {PS, 0,  0};
  const point_t p2 = {p0.x-p1.x, p0.y-p1.y, p0.z-p1.z};
  const float p3=DotProduct(&p2,&p2);
  const float p4=sqrt(p3);
//  sprintf(string,"p3 p4 %f %f\n",p3,p4); debugstring();

  Input();
  UpdateViewPos();
  SetUpFrustum();

  memset(pDIBBase, 0, DIBWidth*DIBHeight);    // clear frame

  DrawVisiblePolygonObjects(&groundobjects[0], sizeof(groundobjects) / sizeof(groundobjects[0])); // table bed and shadows
  DrawObjects();
  const OBJECTS st = { {0,0,0}, 1 };
  DrawVisibleLineObjects(&st, 1, CRT); // lines

  DrawVisiblePolygonObjects(&landobjects[0], sizeof(landobjects) / sizeof(landobjects[0])); // balls and sides
  qsort(&VisibleObject[0], VisibleObjects, sizeof(VisibleObject[0]), ZCompare);
  DrawObjects();

  const OBJECTS ct = { {0,+20,-1840}, CUSHION_T };
  DrawVisibleLineObjects(&ct, 1, CT); // lines
  const OBJECTS ctr = { {+930,+20,910}, CUSHION_TR }; 
  DrawVisibleLineObjects(&ctr, 1, CT); // lines
  const OBJECTS cbr = { {+930,+20,-910}, CUSHION_TL }; 
  DrawVisibleLineObjects(&cbr, 1, CT); // lines
  const OBJECTS cb = { {0,+20,+1840}, CUSHION_B };
  DrawVisibleLineObjects(&cb, 1, CT); // lines
  const OBJECTS cbl = { {-930,+20,-910}, CUSHION_TL }; 
  DrawVisibleLineObjects(&cbl, 1, CT); // lines
  const OBJECTS ctl = { {-930,+20,910}, CUSHION_TR }; 
  DrawVisibleLineObjects(&ctl, 1, CT); // lines

//  const OBJECTS ct3 = { {960,+20,-900}, CUSHION_BL }; 
//  DrawVisibleLineObjects(&ct3, 1, 1); // lines

//  DrawVisiblePolygonObjects(&ct, 1);
//  DrawObjects();

  const HDC hdcScreen = GetDC(hwndOutput); // We've drawn the frame; copy it to the screen
  const HDC hdcDIBSection = CreateCompatibleDC(hdcScreen);
  const HBITMAP holdbitmap = SelectObject(hdcDIBSection, hDIBSection);
  BitBlt(hdcScreen, 0, 0, DIBWidth, DIBHeight, hdcDIBSection, 0, 0, SRCCOPY);
  SelectObject(hdcDIBSection, holdbitmap);
  DeleteDC(hdcDIBSection);
  DeleteObject(holdbitmap);
  ReleaseDC(hwndOutput,hdcScreen);

  Sleep(1); // 20ms = 1/50s
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
  if (!InitApp(hInstance)) // Initialize shared things
  { 
    return FALSE;     // Exits if unable to initialize
  }
  if (!InitInst(hInstance, nCmdShow)) // Perform initializations that apply to a specific instance
  {
    return FALSE;
  }

  MSG msg;
  for (;;) // Acquire and dispatch messages until a WM_QUIT message is received
  {
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
    {
      if (msg.message == WM_QUIT) 
      {
        return (msg.wParam);
      }
      TranslateMessage(&msg);// xlates virt keycodes
      DispatchMessage(&msg); // Dispatches msg to window
    }
    UpdateWorld(); // Update the world
  }
  return (msg.wParam); // Returns the value from PostQuitMessage
}

/*
#include <stdio.h>
#include <math.h>
int main(int argc, char *argv[])
{
        float x1 = -1;        
  float y1 = -1;        
  float z1 = 3;
        float position_x = 1;
        float position_y = 1;
        float position_z = 1;
        float v_x = x1 - position_x;
        float v_y = y1 - position_y;
        float v_z = z1 - position_z;
        float length = sqrt(v_x * v_x + v_z * v_z);
        float pitch = atan2(v_y, length);
        float yaw = atan2(v_z, v_x);
        printf("Pitch = %d\n", (int)(180 * (pitch / 3.1415)));
        printf("Yaw   = %d\n", (int)(180 * (yaw / 3.1415)));
        return 0;
}

inline float zeroClamp( float x )    
{        
  return ( std::fabs(x) > std::numeric_limits<float>::epsilon() ? x : 0.0f );    
}    

inline float wrap( float a )    
{        
  while( a >= RAD360 || a < 0.0f )        
  {            
    if(a >= RAD360 )
                  a -= RAD360;
          else if( a < 0.0f )
                  a += RAD360;        
  }        return a;    
}    

void setRotation( float yaw, float pitch, float roll, bool isInRadians = false ) 
{
        m_yaw = 0.0f;        
  m_pitch = 0.0f;        
  m_roll = 0.0f;        
  rotate( yaw, pitch, roll, isInRadians );    
}    

void rotate( float yaw, float pitch, float roll, bool isInRadians = false ) 
{        
  yaw = zeroClamp( yaw );        
  pitch = zeroClamp( pitch );        
  roll = zeroClamp( roll );        
  if( !isInRadians )        
  {            
    yaw = Rotation3D::deg2rad( yaw );            
    pitch = Rotation3D::deg2rad( pitch );            
    roll = Rotation3D::deg2rad( roll );        
  }        
  m_yaw += yaw;        
  m_yaw = wrap( m_yaw ); // Keep the angle between 0 and 360        
  m_pitch += pitch;        
  m_pitch = wrap( m_pitch );        
  m_roll += roll;        
  m_roll = wrap( m_roll );    
}

#include <stdio.h>#include <math.h>int main(int argc, char *argv[]){        float x1 = -1;        float y1 = -1;        float z1 = 3;        float position_x = 1;        float position_y = 1;        float position_z = 1;        float v_x = x1 - position_x;        float v_y = y1 - position_y;        float v_z = z1 - position_z;        float length = sqrt(v_x * v_x + v_y * v_y + v_z * v_z);        float pitch = asin(v_y / length);        float yaw = atan2(v_z, v_x);        printf("Pitch = %d\n", (int)(180 * (pitch / 3.1415)));        printf("Yaw   = %d\n", (int)(180 * (yaw / 3.1415)));        return 0;}


void lookAt( float x, float y, float z )    
{        
  VectorR3 v( x, y, z );        
  v -= m_position;        
  float r = sqrt( v.x*v.x + v.y*v.y );        
  float yaw = atan2( v.x, v.z );        
  float pitch = atan2( v.y*-1.0f, r );        
  setRotation( yaw, pitch, 0.0f, true );    
}

const D3DXVECTOR3 Display::LookAt(const D3DXVECTOR3 &location, const D3DXVECTOR3 &camera)
{
  const D3DXVECTOR3 diff=camera-location;
  const float y=atan2(diff.z, diff.x);
  const float x=atan2(diff.y, sqrtf((diff.x*diff.x)+(diff.z*diff.z)));
  return D3DXVECTOR3(x,y,0);
}

*/